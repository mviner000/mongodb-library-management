all logic for "Valid data" is working properly. but
why only "_id" and "errors" are the columns in my "invalid table" when csv temp file is created, ill show you my "csv attendance for the e.g".
just for your reference to solve the issue, please if there are more columns name with contents, add it also to the "invalid table created".
just focusing in solving why only "_id" and "errors" are the columns in my "invalid table" when csv temp file is created.
temp data dir logs with python to show tables and columns.
ssd-ubuntu2:attendance$ ls
print_tables_and_columns.py  temp_data.sqlite
ssd-ubuntu2:attendance$ ./print_tables_and_columns.py

ðŸ“‹ Table: valid_data
   - _id (TEXT)

ðŸ“‹ Table: invalid_data
   - _id (TEXT)
   - errors (TEXT)

--> print_tables_and_columns.py

#!/usr/bin/env python3

import sqlite3

def print_tables_and_columns(db_path):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Get all table names
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    tables = cursor.fetchall()

    if not tables:
        print("No tables found in the database.")
        return

    for table_name, in tables:
        print(f"\nðŸ“‹ Table: {table_name}")
        cursor.execute(f"PRAGMA table_info('{table_name}');")
        columns = cursor.fetchall()
        for col in columns:
            cid, name, col_type, notnull, default, pk = col
            print(f"   - {name} ({col_type})")

    conn.close()

if __name__ == "__main__":
    db_path = "temp_data.sqlite"
    print_tables_and_columns(db_path)

rust backend logs:
DEBUG: String param: ["Invalid date in time_in_date"]
DEBUG: Executing INSERT with 2 params
DEBUG: Successfully inserted invalid data row 127
DEBUG: Processing invalid data row 128
DEBUG: Found object with 14 keys
DEBUG: Generated UUID as _id: 44eb7d88-d0b8-47c5-9ef4-22ee4e7e388d
DEBUG: Extracting values for 0 columns
DEBUG: Found errors: ["Invalid date in time_in_date"]
DEBUG: Converting 2 values to params
DEBUG: String param: 44eb7d88-d0b8-47c5-9ef4-22ee4e7e388d
DEBUG: String param: ["Invalid date in time_in_date"]
DEBUG: Executing INSERT with 2 params
DEBUG: Successfully inserted invalid data row 128
DEBUG: Processing invalid data row 129
DEBUG: Found object with 14 keys
DEBUG: Generated UUID as _id: fcfee986-659f-4256-800c-c9ae90bc7bc8
DEBUG: Extracting values for 0 columns
DEBUG: Found errors: ["Invalid date in time_in_date"]
DEBUG: Converting 2 values to params
DEBUG: String param: fcfee986-659f-4256-800c-c9ae90bc7bc8
DEBUG: String param: ["Invalid date in time_in_date"]
DEBUG: Executing INSERT with 2 params
DEBUG: Successfully inserted invalid data row 129
DEBUG: Successfully inserted all invalid data (129 rows)
2025-04-22T13:08:28.391836Z  INFO vue_tauri_lib::api_server::handlers::csv_temp_handlers: Successfully completed database operations for collection: /home/ssd-ubuntu2/.local/share/vue-tauri/temp/attendance/temp_data.sqlite
2025-04-22T13:08:28.392298Z  INFO vue_tauri_lib::api_server::handlers::csv_temp_handlers: Successfully saved CSV data to temp storage for collection: attendance.

--> csv data uploaded:
oid,school_id,full_name,created_at,time_in_date,classification,purpose_label
0dd02661-a98f-4f8b-b469-cbad8cf45a0c,52311023,NIJENA AISYL SALONGA GABRIEL,01/16/2025,03:59 PM,BSA,Reading/Study/Review
f8cc2c8f-5244-467b-83a7-1d9ac3225d07,52311023,SAMANTHA JANE GUTIERREZ GONZALES,01/16/2025,03:16 PM,BSAIS,Research
50b819d2-04f0-4dd1-acad-36249d633a10,52310187,THRICSIE SALVADOR PALPAGON,01/16/2025,03:16 PM,BSAIS,Research etc...
<!-- src/views/CSVImportView.vue -->
<script setup lang="ts">
  import { ref, computed, onMounted, onUnmounted } from 'vue'
  import { useRoute } from 'vue-router'
  import { useToast } from '@/components/ui/toast'
  import { Button } from '@/components/ui/button'
  import { storeToRefs } from 'pinia'
  import MongoDBDataTable from '@/components/MongoDBDataTable.vue'
  import { parseCSV } from '@/utils/parseCSV'
  import { useDataTableStore } from '@/store/dataTableStore'
  import { getApiBaseUrl } from '@/utils/api'

  const route = useRoute()
  const { toast } = useToast()
  const dataTableStore = useDataTableStore()
  const { collectionSchema } = storeToRefs(dataTableStore)
  const collectionName = computed(() => route.params.name as string)
  const primaryKey = computed(() => {
    return collectionSchema.value?.primaryKey
  })
  const previewData = ref<any[]>([])
  const fileInput = ref<HTMLInputElement | null>(null)
  const hasImportedData = ref(false)

  const handleFileUpload = async (event: Event) => {
    const file = (event.target as HTMLInputElement).files?.[0]
    if (!file) return

    try {
      const { data: csvData } = await parseCSV(file)
      const schema = collectionSchema.value.properties || {}

      // Create short name map for field mapping
      const shortNameMap = createShortNameMap(schema)

      // Check for required columns
      const csvHeaders = csvData.length > 0 ? Object.keys(csvData[0]) : []
      const missingRequired = primaryKey.value
        ? !csvHeaders.includes(shortNameMap[primaryKey.value] || primaryKey.value)
          ? [primaryKey.value]
          : []
        : []

      if (missingRequired.length > 0) {
        toast({
          title: 'Invalid CSV Format',
          description: `Missing primary key column: ${missingRequired.join(', ')}`,
          variant: 'destructive',
        })
        return
      }

      // Validate CSV data and split into valid/invalid
      const { valid: validData, invalid: invalidData } = validateCSVData(csvData, schema)

      // Show upload counts in toast
      const validCount = validData.length
      const invalidCount = invalidData.length
      toast({
        title: `CSV Import Results`,
        description: `Valid data: ${validCount}, Invalid data: ${invalidCount}`,
        duration: 5000,
      })

      // Transform valid data for storage
      const transformedValid = transformCSVData(validData, shortNameMap, collectionSchema.value)

      // Transform invalid data to match schema columns as strings
      const transformedInvalid = invalidData.map(({ row, errors }) => {
        const transformedRow: Record<string, string> = {}

        Object.keys(collectionSchema.value.properties).forEach((field) => {
          const csvKey = shortNameMap[field] || field
          const value = row[csvKey]
          transformedRow[field] = value !== undefined ? String(value) : ''
        })

        return {
          ...transformedRow,
          errors,
        }
      })

      // Send to backend
      const response = await fetch(`${getApiBaseUrl()}/api/csv-temp/${collectionName.value}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ valid: transformedValid, invalid: transformedInvalid }),
      })

      if (!response.ok) throw new Error('Failed to save temporary data')

      // After transforming data
      previewData.value = transformedValid
      // Use MongoDB-compatible ObjectID for selection
      dataTableStore.selectedRows = new Set(transformedValid.map((doc: any) => doc._id.$oid))
      hasImportedData.value = true
      toast({ title: 'CSV Processed', description: 'Data successfully imported' })
    } catch (error: any) {
      // Handle parsing/validation errors
      toast({ title: 'Import Failed', description: error.message, variant: 'destructive' })
    }
  }

  // Helper functions
  const validateCSVData = (
    data: any[],
    schema: Record<string, any>
  ): { valid: any[]; invalid: Array<{ row: any; errors: string[] }> } => {
    const valid: any[] = []
    const invalid: Array<{ row: any; errors: string[] }> = []

    data.forEach((row, index) => {
      const errors: string[] = []

      // Primary key field check
      if (primaryKey.value) {
        const value = row[primaryKey.value]
        if (value === null || value === undefined || value === '') {
          errors.push(`Missing primary key field: ${primaryKey.value}`)
        }
      }

      // Type validation
      Object.entries(row).forEach(([field, value]) => {
        const fieldSchema = schema[field]
        if (!fieldSchema || value === null || value === '') return

        const type = Array.isArray(fieldSchema.bsonType)
          ? fieldSchema.bsonType[0]
          : fieldSchema.bsonType

        if (
          (type === 'number' || type === 'int' || type === 'double' || type === 'long') &&
          isNaN(Number(value))
        ) {
          errors.push(`Invalid number in ${field}`)
        }

        if (
          type === 'bool' &&
          !['true', 'false', '0', '1', 'yes', 'no', ''].includes(String(value).toLowerCase())
        ) {
          errors.push(`Invalid boolean value in ${field}`)
        }

        if (type === 'date' && isNaN(Date.parse(String(value)))) {
          errors.push(`Invalid date in ${field}`)
        }
      })

      if (errors.length > 0) {
        invalid.push({ row, errors })
      } else {
        valid.push(row)
      }
    })

    return { valid, invalid }
  }

  const createShortNameMap = (schema: Record<string, any>) => {
    return Object.keys(schema).reduce(
      (acc, field) => {
        acc[field] = schema[field]?.ui?.short_name || field
        return acc
      },
      {} as Record<string, string>
    )
  }

  const convertValueBySchema = (value: any, fieldSchema: any) => {
    if (value === null || value === undefined || value === '') return null

    const type = Array.isArray(fieldSchema.bsonType)
      ? fieldSchema.bsonType[0]
      : fieldSchema.bsonType

    switch (type) {
      case 'bool':
        if (value === '1' || value === 'yes' || String(value).toLowerCase() === 'true') return true
        if (value === '0' || value === 'no' || String(value).toLowerCase() === 'false') return false
        return null
      case 'int':
      case 'long':
        return parseInt(value, 10)
      case 'double':
      case 'number':
        return parseFloat(value)
      case 'date':
        try {
          return new Date(value).toISOString()
        } catch {
          return null
        }
      default:
        return value
    }
  }

  const transformCSVData = (data: any[], shortNameMap: Record<string, string>, schema: any) => {
    const schemaFields = Object.keys(schema.properties || {})

    return data.map((row) => {
      const transformed: Record<string, any> = {}

      // Map all schema fields
      schemaFields.forEach((field) => {
        // Find the CSV column that corresponds to this schema field
        const csvKey =
          Object.entries(shortNameMap).find(([_, shortName]) => shortName === field)?.[0] || field

        const rawValue = row[csvKey]
        // Convert values based on schema type
        transformed[field] = schema.properties[field]
          ? convertValueBySchema(rawValue, schema.properties[field])
          : rawValue === '' || rawValue === undefined
            ? null
            : rawValue
      })

      // Add MongoDB-compatible ObjectID instead of numeric ID
      transformed._id = { $oid: generateMongoObjectId() }

      // Add timestamps if they're part of the schema
      const now = new Date().toISOString()
      if (schemaFields.includes('created_at')) {
        transformed.created_at = transformed.created_at || now
      }

      if (schemaFields.includes('updated_at')) {
        transformed.updated_at = transformed.updated_at || now
      }

      return transformed
    })
  }

  // Function to generate MongoDB-compatible ObjectIDs
  function generateMongoObjectId(): string {
    const timestamp = Math.floor(new Date().getTime() / 1000)
      .toString(16)
      .padStart(8, '0')
    const machineId = randomHexString(6)
    const processId = randomHexString(4)
    const counter = randomHexString(6)

    return timestamp + machineId + processId + counter
  }

  // Helper function to generate random hex strings of specified length
  function randomHexString(length: number): string {
    let result = ''
    const characters = '0123456789abcdef'
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length))
    }
    return result
  }

  onMounted(async () => {
    try {
      // Load from SQLite backend
      const response = await fetch(`${getApiBaseUrl()}/api/csv-temp/${collectionName.value}`)

      if (response.ok) {
        const data = await response.json()
        previewData.value = data.valid || data // Support both old and new format
        hasImportedData.value = previewData.value.length > 0

        // Auto-select all rows when loading saved data - use MongoDB ObjectID format
        const ids = previewData.value.map((doc: any) => doc._id?.$oid)
        dataTableStore.selectedRows = new Set(ids.filter(Boolean)) // Filter out any undefined IDs

        console.log(`Loaded saved CSV data with ${previewData.value.length} rows`)
      }
    } catch (error) {
      console.error('Error loading saved CSV data:', error)
    }
  })

  const triggerFileSelect = () => {
    fileInput.value?.click()
  }

  const resetImport = async () => {
    try {
      // Delete from SQLite backend instead of localStorage
      await fetch(`${getApiBaseUrl()}/api/csv-temp/${collectionName.value}`, { method: 'DELETE' })

      previewData.value = []
      hasImportedData.value = false
      // Clear selected rows when resetting
      dataTableStore.selectedRows = new Set()
      if (fileInput.value) {
        fileInput.value.value = ''
      }
      toast({ title: 'Reset Complete', description: 'Temporary data cleared' })
    } catch (error: any) {
      toast({ title: 'Reset Failed', description: error.message, variant: 'destructive' })
    }
  }

  onUnmounted(() => {
    // Clear selected rows when component is unmounted
    dataTableStore.selectedRows = new Set()
  })
</script>

<template>
  <!-- Conditional rendering based on whether data is imported -->
  <div
    v-if="!hasImportedData"
    class="file-import-container"
  >
    <input
      ref="fileInput"
      type="file"
      accept=".csv"
      class="hidden"
      @change="handleFileUpload"
    />

    <div class="excel-inspired-import">
      <div class="import-header">
        <h2>Import CSV to {{ collectionName }}</h2>
        <p class="import-subtitle">Add data to your collection from a CSV file</p>
      </div>

      <div
        class="import-dropzone"
        @click="triggerFileSelect"
      >
        <div class="dropzone-content">
          <div class="excel-icon">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="48"
              height="48"
            >
              <path
                fill="none"
                d="M0 0h24v24H0z"
              />
              <path
                d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm1 5h-5V4h1v2h4v1zm-8 5h3v-1H7v1zm0 2h3v-1H7v1zm0 2h8v-1H7v1zm8-6v-1H7v1h8z"
                fill="#107C41"
              />
            </svg>
          </div>
          <p class="dropzone-text">
            <span class="font-bold">Select a CSV file</span> or drag and drop it here
          </p>
          <div class="mt-4">
            <Button class="primary-button">Browse Files</Button>
          </div>
          <p class="text-xs text-gray-500 mt-2">
            Make sure your CSV has headers matching the collection schema
          </p>
        </div>
      </div>

      <div
        v-if="fileInput?.files?.[0]"
        class="selected-file"
      >
        <span class="file-name">{{ fileInput.files[0].name }}</span>
        <span class="file-size">{{ (fileInput.files[0].size / 1024).toFixed(1) }} KB</span>
      </div>
    </div>
  </div>

  <!-- Table view when data is imported -->
  <div v-else>
    <div class="csv-import-container">
      <MongoDBDataTable
        :selected-collection="collectionName"
        :preview-data="previewData"
        preview-mode
      />
    </div>
  </div>

  <!-- Reset button - completely separate from the content flow -->
  <button
    v-if="hasImportedData"
    @click="resetImport"
    class="fixed bottom-4 left-4 z-40 flex items-center px-4 py-2 text-sm font-medium text-white bg-red-600 hover:bg-red-700 rounded-full shadow-lg transition-colors duration-200 ease-in-out"
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
      class="mr-2"
    >
      <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
      <path d="M3 3v5h5" />
      <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" />
      <path d="M16 16h5v5" />
    </svg>
    Reset
  </button>
</template>

<style scoped>
  .csv-import-container {
    @apply px-4 max-w-full overflow-x-auto;
  }

  .file-import-container {
    @apply p-6 max-w-3xl mx-auto;
  }

  .excel-inspired-import {
    @apply bg-white rounded-lg shadow-md border border-gray-200;
  }

  .import-header {
    @apply p-4 border-b border-gray-200;
  }

  .import-header h2 {
    @apply text-xl font-semibold text-gray-800;
  }

  .import-subtitle {
    @apply text-sm text-gray-500 mt-1;
  }

  .import-dropzone {
    @apply p-8 flex flex-col items-center justify-center cursor-pointer transition-all duration-200 hover:bg-gray-50;
  }

  .dropzone-content {
    @apply flex flex-col items-center justify-center gap-3;
  }

  .excel-icon {
    @apply mb-3;
  }

  .dropzone-text {
    @apply text-gray-600 text-center;
  }

  .primary-button {
    @apply bg-green-600 hover:bg-green-700 text-white;
  }

  .selected-file {
    @apply p-4 border-t border-gray-200 flex justify-between items-center text-sm;
  }

  .file-name {
    @apply font-medium text-gray-700;
  }

  .file-size {
    @apply text-gray-500;
  }
</style>

<!-- src/components/MongoDBDataTable.vue -->
<script setup lang="ts">
  // ==========================================================================
  // Imports
  // ==========================================================================
  import {
    ref,
    computed,
    watch,
    onMounted,
    Ref,
    inject,
    nextTick,
    onBeforeUnmount,
    reactive,
  } from 'vue' // [cite: 1]
  import { useRoute, useRouter } from 'vue-router' // [cite: 1]
  import { storeToRefs } from 'pinia' // [cite: 1]
  import { useDebounceFn, useThrottleFn } from '@vueuse/core' // [cite: 1]

  // Store Imports
  import { useDataTableStore } from '@/store/dataTableStore' // [cite: 1]
  import { useUserStore } from '@/store/useUserStore' // [cite: 4]

  // UI Component Imports
  import { Cross2Icon, ReloadIcon, PlusCircledIcon } from '@radix-icons/vue' // [cite: 1]
  import { Button } from '@/components/ui/button' // [cite: 1]
  import { Input } from '@/components/ui/input' // [cite: 1]
  import { TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table' // [cite: 2]
  import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
  } from '@/components/ui/select' // [cite: 2]
  import {
    NavigationMenu,
    NavigationMenuContent,
    NavigationMenuItem,
    NavigationMenuList,
    NavigationMenuTrigger,
  } from './ui/navigation-menu' // [cite: 3]
  import { ScrollArea } from '@/components/ui/scroll-area' // [cite: 3]
  import Switch from './ui/switch/Switch.vue' // [cite: 4]
  import Label from './ui/label/Label.vue' // [cite: 4]
  import { useToast } from '@/components/ui/toast/use-toast'

  // Custom Component Imports
  import ExcelCellReference from './ExcelCellReference.vue' // [cite: 4]
  import TableActions from './mongodbtable/TableActions.vue' // [cite: 4]
  import StickyTableActions from './mongodbtable/StickyTableActions.vue' // [cite: 4]
  import MongoDBDataTableNavbar from './MongoDBDataTableNavbar.vue' // [cite: 4]
  import StickyLeftSidebar from './StickyLeftSidebar.vue' // [cite: 4]
  import CSVCellReference from './CSVCellReference.vue'
  import { getApiBaseUrl, getAuthHeaders } from '@/utils/api'
  import Dialog from './ui/dialog/Dialog.vue'
  import DialogContent from './ui/dialog/DialogContent.vue'
  import DialogTitle from './ui/dialog/DialogTitle.vue'
  import DialogHeader from './ui/dialog/DialogHeader.vue'
  import DialogFooter from './ui/dialog/DialogFooter.vue'

  // ==========================================================================
  // Store Setup
  // ==========================================================================
  const dataTableStore = useDataTableStore() // [cite: 4]
  const userStore = useUserStore() // [cite: 7]

  // Destructured State & Getters (Reactive Refs)
  const { user } = storeToRefs(userStore) // [cite: 7]
  const {
    collectionName,
    collectionSchema,
    isLoading,
    errorMessage,
    pageSize,
    currentPage,
    newDocument,
    isAdding,
    editingCell,
    editValue,
    isSaving,
    selectedRows,
    currentView,
    pendingDeleteId,
    referenceOptions,
    loadingReferences,
    errorColumn,
    addingRowError,
    totalPages,
    tableHeaders,
    columnWidths,
    allSelected,
    hiddenColumns,
    visibleHeaders,
    previewMode,
  } = storeToRefs(dataTableStore) // [cite: 4, 5]

  // Destructured Actions (Functions)
  const {
    fetchCollections,
    setCollection,
    fetchDocuments,
    fetchReferenceOptions,
    getReferenceLabel,
    startAdding,
    cancelAdding,
    saveNewDocument,
    startEditingCell,
    cancelEdit,
    saveEdit,
    toggleRow,
    resetSelection,
    changeView,
    setPage, // Renamed from onPageChange
    setPageSize, // Added action
    updateColumnWidth,
    resetColumnWidth,
    saveColumnWidthsToBackend,
    clearError, // Renamed from closeError
    getSchemaInfo,
    isReferenceField,
    getReferencedCollection,
    updateUIMetadata,
    toggleColumnVisibility,
    updateDocumentField, // Added [cite: 55]
    pinDocument, // Added [cite: 43]
    unpinDocument, // Added [cite: 43]
    // fetchSchema, // Optional direct access
  } = dataTableStore // [cite: 5, 6, 7, 43, 47, 55, 61]

  // ==========================================================================
  // Props
  // ==========================================================================
  const props = defineProps<{
    selectedCollection?: string
    name?: string
    previewData?: any[]
  }>() // [cite: 11]

  // ==========================================================================
  // Local Component State
  // ==========================================================================
  const route = useRoute() // [cite: 7]
  const router = useRouter() // [cite: 7]
  const isSplit = inject<Ref<boolean>>('isSplit')! // [cite: 7]
  const scrollContainer = ref<HTMLElement | null>(null)
  const isLoadingMore = ref(false)
  const isSidebarOpen = ref(false) // [cite: 9]
  const searchQuery = ref<Record<string, string>>({}) // [cite: 9]
  const selectedCell = ref<{ colIndex: number; rowNumber: number } | null>(null) // [cite: 10]
  const timeoutId = ref<number | null>(null) // For error message timeout [cite: 11]
  const showPinTooltip = ref(false) // [cite: 11]
  const highlightedColumn = ref<string | null>(null) // [cite: 62]
  const showContextMenu = ref(false) // [cite: 40]
  const contextMenuPosition = ref({ x: 0, y: 0 }) // [cite: 40]
  const selectedCellInfo = ref<{ rowIndex: number; header: string } | null>(null) // [cite: 41]
  const highlightedDocumentId = ref<string | null>(null) // [cite: 49]
  let highlightTimeout: ReturnType<typeof setTimeout> | null = null // [cite: 49]
  const editingHeader = ref<string | null>(null) // [cite: 59]
  const editedShortName = ref('') // [cite: 59]
  const { toast } = useToast()

  // Resizing States
  const resizingState = ref({
    isResizing: false,
    header: '',
    startX: 0,
    startWidth: 0,
    currentWidth: 0,
  }) // [cite: 9]
  const alphaResizingState = ref({
    isResizing: false,
    columnIndex: -1,
    startX: 0,
    startWidth: 0,
    currentWidth: 0,
  }) // [cite: 9]
  const rowResizingState = ref({
    isResizing: false,
    documentId: '',
    startY: 0,
    startHeight: 40, // Default row height
    currentHeight: 40,
  }) // [cite: 51, 52]

  // Drag State
  const dragState = reactive({
    isDragging: false,
    draggedIndex: -1,
    targetIndex: -1,
  }) // [cite: 65]

  // ==========================================================================
  // Computed Properties
  // ==========================================================================
  const documents = computed(() => {
    if (props.previewData) {
      // Directly use previewData from SQLite backend
      return props.previewData.map((doc) => ({
        ...doc,
        // Ensure proper ObjectID format
        _id: doc._id?.$oid ? doc._id : { $oid: doc._id },
      }))
    }
    return dataTableStore.documents
  })

  const paginatedDocuments = computed(() => {
    if (props.previewData) {
      // Preview mode: Show all data without pagination
      return documents.value // [cite: 72]
    } else {
      // Regular mode: Use store pagination
      const start = (currentPage.value - 1) * pageSize.value // [cite: 72]
      const end = start + pageSize.value // [cite: 72]
      return documents.value.slice(start, end) // [cite: 72]
    }
  })

  const columnLetters = computed(() => {
    return visibleHeaders.value.map((_, index) => getColumnLabel(index)) // [cite: 12]
  })

  const numberColumnWidth = computed(() => {
    const maxDigits = documents.value.length > 0 ? String(documents.value.length).length : 1 // [cite: 12]
    return `${Math.max(3, maxDigits + 1)}ch` // [cite: 12]
  })

  const totalTableWidth = computed(() => {
    // Calculate the total width of visible data columns
    const dataColumnsWidth = visibleHeaders.value.reduce(
      (acc, header) => acc + (columnWidths.value[header] || 200), // Default width if not specified [cite: 13, 14]
      0
    )

    const selectColWidth = 40 // Width for the selection column [cite: 14]
    const rowNumColWidth = 30 // Width for the row number column [cite: 14]
    const actionsColWidth = 60 // Width for the actions column [cite: 14]

    // Return the total width including only visible columns
    return selectColWidth + rowNumColWidth + dataColumnsWidth + actionsColWidth + 1 // +1 for border [cite: 14]
  })

  const isSelectedArchived = computed(() => {
    if (!selectedCellInfo.value) {
      return false // [cite: 45]
    }

    const rowIndex = selectedCellInfo.value.rowIndex // [cite: 45]
    const document = paginatedDocuments.value[rowIndex] // [cite: 45]
    const isArchived = document?.is_archive === true // [cite: 46]

    return isArchived // [cite: 46]
  })

  const selectedDocumentIsPinned = computed(() => {
    if (!selectedCellInfo.value) return false // [cite: 46]
    if (!user.value) return false // Add this check for null user [cite: 46]

    const doc = paginatedDocuments.value[selectedCellInfo.value.rowIndex] // [cite: 46]
    return doc?.pinned_by?.includes(user.value.id) // [cite: 46]
  })

  const pinnedDocuments = computed(() => {
    if (!user.value) return [] // [cite: 47]
    return documents.value.filter((doc) => doc.pinned_by?.includes(user.value?.id)) // [cite: 47]
  })

  const previewRowHeights = computed(() => {
    if (!previewMode.value || !collectionName.value) return {} // [cite: 55, 56]
    const heights = sessionStorage.getItem(`previewRowHeights-${collectionName.value}`) // [cite: 56]
    return heights ? JSON.parse(heights) : {} // [cite: 56, 57]
  })

  const isImportRoute = computed(() => route.path.includes('/import-csv')) // [cite: 71]

  // ==========================================================================
  // Watchers
  // ==========================================================================

  // Watch route parameter 'name'
  watch(
    () => route.params.name,
    (newName) => {
      if (previewMode.value) return // Skip in preview [cite: 18]
      const nameStr = Array.isArray(newName) ? newName[0] : newName // [cite: 18]
      if (nameStr && nameStr !== collectionName.value) {
        setCollection(nameStr) // [cite: 18]
      }
    },
    { immediate: true } // [cite: 19]
  )

  // Watch the prop 'selectedCollection'
  watch(
    () => props.selectedCollection,
    (newVal) => {
      if (newVal && newVal !== collectionName.value) {
        setCollection(newVal) // [cite: 19]
        if (route.params.name !== newVal) {
          router.push(`/collection/${newVal}`) // [cite: 19]
        }
      }
    }
  )

  // Watch the store's collectionName to sync the route if needed
  watch(collectionName, (newName, oldName) => {
    if (newName && newName !== oldName && route.params.name !== newName) {
      router.push(`/collection/${newName}`) // [cite: 20]
    }
  })

  // Watch for error message to auto-clear
  watch(errorMessage, (newVal) => {
    if (newVal) {
      if (timeoutId.value) {
        clearTimeout(timeoutId.value) // [cite: 20]
      }
      timeoutId.value = setTimeout(() => {
        clearError() // Use store action [cite: 21]
        timeoutId.value = null // [cite: 21]
      }, 2500) as unknown as number // [cite: 21]
    }
  })

  // Watch isAdding to prefetch reference options
  watch(isAdding, async (newVal) => {
    if (newVal) {
      tableHeaders.value.forEach((field) => {
        // Use tableHeaders getter [cite: 21]
        const refCollection = getReferencedCollection(field) // [cite: 21]
        if (refCollection && !referenceOptions.value[refCollection]) {
          // [cite: 22]
          fetchReferenceOptions(refCollection) // Use store action [cite: 22]
        }
      })
    }
  }) // [cite: 22]

  // Watch previewMode (removed console.log)
  watch(
    previewMode,
    () => {
      // All console.log statements removed [cite: 69]
    },
    { immediate: true }
  )

  // Watch route to set preview mode
  watch(
    isImportRoute,
    (newVal) => {
      previewMode.value = newVal // [cite: 71]
    },
    { immediate: true } // [cite: 71]
  )

  // ==========================================================================
  // Lifecycle Hooks
  // ==========================================================================
  onMounted(async () => {
    if (previewMode.value) return // Skip fetching in preview mode [cite: 22]

    await fetchCollections() // [cite: 22]
    const routeName = Array.isArray(route.params.name) ? route.params.name[0] : route.params.name // [cite: 23]
    const initialCollection = routeName || props.selectedCollection // [cite: 24]

    if (initialCollection && initialCollection !== collectionName.value) {
      await setCollection(initialCollection) // [cite: 24]
    } else if (collectionName.value && documents.value.length === 0 && !isLoading.value) {
      try {
        await dataTableStore.fetchSchema() // [cite: 24]
        await dataTableStore.fetchDocuments() // [cite: 24]
      } catch (error) {
        // Handle error [cite: 24]
      }
    }

    // Event listeners
    window.addEventListener('click', closeContextMenu) // [cite: 45]
    document.addEventListener('click', checkClickOutsideHeaders) // [cite: 45]
  })

  onBeforeUnmount(() => {
    // Cleanup listeners
    document.removeEventListener('click', checkClickOutsideHeaders) // [cite: 45]
    window.removeEventListener('click', closeContextMenu) // [cite: 45]

    // Clear any pending timeouts
    if (timeoutId.value) {
      clearTimeout(timeoutId.value)
    }
    if (highlightTimeout) {
      clearTimeout(highlightTimeout)
    }
  })

  // ==========================================================================
  // Utility Functions
  // ==========================================================================
  const getColumnLabel = (index: number): string => {
    let label = '' // [cite: 11]
    let i = index // [cite: 11]
    do {
      const remainder = i % 26 // [cite: 11]
      label = String.fromCharCode(65 + remainder) + label // [cite: 12]
      i = Math.floor(i / 26) - 1 // [cite: 12]
    } while (i >= 0)
    return label // [cite: 12]
  } // [cite: 12]

  const isFieldRequired = (field: string): boolean => {
    return collectionSchema.value.required?.includes(field) || false // [cite: 15]
  } // [cite: 15]

  const formatSchemaValue = (value: any, bsonType?: string | string[]) => {
    if (value === undefined || value === null) return '' // Handle null/undefined early

    const type = bsonType ? (Array.isArray(bsonType) ? bsonType[0] : bsonType) : typeof value

    // Handle empty strings for non-string types
    if (typeof value === 'string' && value.trim() === '') {
      return ''
    }

    if (type === 'date') {
      try {
        return value instanceof Date ? value.toLocaleString() : new Date(value).toLocaleString()
      } catch {
        return '' // Return empty for invalid dates
      }
    }

    if (typeof value === 'object') {
      return JSON.stringify(value, null, 2)
    }

    return String(value)
  }

  const filteredOptions = (field: string) => {
    const refCollection = getReferencedCollection(field) // [cite: 17]
    if (!refCollection) return [] // [cite: 17]
    const options = referenceOptions.value[refCollection] || [] // [cite: 17, 18]
    const query = (searchQuery.value[field] || '').toLowerCase() // [cite: 18]
    return options.filter((opt) => opt.label.toLowerCase().includes(query)) // [cite: 18]
  } // [cite: 18]

  const shortName = (header: string) => {
    return collectionSchema.value.ui?.short_names?.[header] || header // [cite: 59, 60]
  }

  function getActualIndex(visibleIndex: number) {
    let actualIndex = 0 // [cite: 65]
    let visibleCount = 0 // [cite: 65]

    while (visibleCount <= visibleIndex && actualIndex < tableHeaders.value.length) {
      // [cite: 65]
      if (!hiddenColumns.value.includes(tableHeaders.value[actualIndex])) {
        // [cite: 65]
        visibleCount++ // [cite: 65]
      }
      actualIndex++ // [cite: 65]
    }

    return actualIndex - 1 // [cite: 66]
  }

  // ==========================================================================
  // Debounced Functions
  // ==========================================================================
  const debouncedSaveWidths = useDebounceFn(async () => {
    await saveColumnWidthsToBackend() // Call store action [cite: 25]
  }, 750) // Keep debounce consistent [cite: 25]

  const debouncedRowHeightSave = useDebounceFn(async (documentId: string, height: number) => {
    try {
      // [cite: 54]
      await updateDocumentField(documentId, 'row_height', height) // [cite: 55]
    } catch (error) {
      // Error handling without console.error [cite: 55]
    }
  }, 500) // 500ms delay [cite: 55]

  // ==========================================================================
  // Methods
  // ==========================================================================

  // --- Error Handling ---
  const closeErrorManual = () => {
    if (timeoutId.value) {
      clearTimeout(timeoutId.value) // [cite: 25]
      timeoutId.value = null // [cite: 25]
    }
    clearError() // Use store action [cite: 25]
  } // Matches original @click="closeError" [cite: 25]

  // --- Column Resizing ---
  const startAlphaResize = (columnIndex: number, event: MouseEvent) => {
    const header = tableHeaders.value[columnIndex] // Use getter [cite: 26]
    if (!header) return // [cite: 26]
    const currentWidth = columnWidths.value[header] || 200 // Use getter [cite: 26, 27]

    alphaResizingState.value = {
      isResizing: true,
      columnIndex,
      startX: event.clientX,
      startWidth: currentWidth,
      currentWidth: currentWidth,
    } // [cite: 27]
    document.addEventListener('mousemove', handleAlphaMouseMove) // [cite: 27]
    document.addEventListener('mouseup', stopAlphaResize) // [cite: 27]
    event.preventDefault() // [cite: 27]
  } // [cite: 27]

  const handleAlphaMouseMove = (event: MouseEvent) => {
    if (!alphaResizingState.value.isResizing) return // [cite: 27]
    const delta = event.clientX - alphaResizingState.value.startX // [cite: 27]
    const newWidth = Math.max(50, alphaResizingState.value.startWidth + delta) // [cite: 27]
    alphaResizingState.value.currentWidth = newWidth // [cite: 28]

    const header = tableHeaders.value[alphaResizingState.value.columnIndex] // [cite: 28]
    if (header && collectionSchema.value.ui) {
      // Temporarily update local schema for visual feedback [cite: 28]
      collectionSchema.value.ui.columnWidths = {
        ...collectionSchema.value.ui.columnWidths,
        [header]: newWidth,
      } // [cite: 28]
    }
  }

  const stopAlphaResize = async () => {
    if (!alphaResizingState.value.isResizing) return // [cite: 28]
    const header = tableHeaders.value[alphaResizingState.value.columnIndex] // [cite: 28]
    const finalWidth = alphaResizingState.value.currentWidth // [cite: 28]
    alphaResizingState.value.isResizing = false // [cite: 29]
    document.removeEventListener('mousemove', handleAlphaMouseMove) // [cite: 29]
    document.removeEventListener('mouseup', stopAlphaResize) // [cite: 29]

    if (header) {
      await updateColumnWidth(header, finalWidth) // Update store [cite: 29]
      debouncedSaveWidths() // Trigger debounced save [cite: 29]
    }
  }

  const resetAlphaColumnWidth = async (columnIndex: number) => {
    const header = tableHeaders.value[columnIndex] // [cite: 29]
    if (header) {
      await resetColumnWidth(header) // Update store [cite: 29]
      debouncedSaveWidths() // Trigger save [cite: 29]
    }
  } // [cite: 29]

  const startResize = (header: string, event: MouseEvent) => {
    const currentWidth = columnWidths.value[header] || 200 // [cite: 30, 31]
    resizingState.value = {
      isResizing: true,
      header,
      startX: event.clientX,
      startWidth: currentWidth,
      currentWidth: currentWidth,
    } // [cite: 31]
    document.addEventListener('mousemove', handleMouseMove) // [cite: 31]
    document.addEventListener('mouseup', stopResize) // [cite: 31]
    event.preventDefault() // [cite: 31]
  } // [cite: 31]

  const handleMouseMove = (event: MouseEvent) => {
    if (!resizingState.value.isResizing) return // [cite: 31]
    const delta = event.clientX - resizingState.value.startX // [cite: 31]
    const newWidth = Math.max(50, resizingState.value.startWidth + delta) // [cite: 31]
    resizingState.value.currentWidth = newWidth // [cite: 32]

    const header = resizingState.value.header // [cite: 32]
    if (header && collectionSchema.value.ui) {
      // Temporarily update local schema for visual feedback [cite: 32]
      collectionSchema.value.ui.columnWidths = {
        ...collectionSchema.value.ui.columnWidths,
        [header]: newWidth,
      } // [cite: 32]
    }
  }

  const stopResize = async () => {
    if (!resizingState.value.isResizing) return // [cite: 32]
    const header = resizingState.value.header // [cite: 32]
    const finalWidth = resizingState.value.currentWidth // [cite: 32]
    resizingState.value.isResizing = false // [cite: 33]
    document.removeEventListener('mousemove', handleMouseMove) // [cite: 33]
    document.removeEventListener('mouseup', stopResize) // [cite: 33]

    if (header) {
      await updateColumnWidth(header, finalWidth) // Update store [cite: 33]
      debouncedSaveWidths() // Trigger save [cite: 33]
    }
  }

  // Commented out original reset function as it might clash with store action name
  // const resetColumnWidth = async (header: string) => { // Renamed from original resetDataColumnWidth for clarity
  //   await resetColumnWidth(header); // Call store action (make sure names don't clash) [cite: 33]
  //   debouncedSaveWidths(); // [cite: 34]
  // }; // [cite: 35]

  // --- Row Resizing ---
  const startRowResize = (documentId: string, event: MouseEvent) => {
    const doc = documents.value.find((d) => d._id.$oid === documentId) // [cite: 52]
    if (!doc) return // [cite: 52]

    const currentHeight = doc.row_height || 40 // [cite: 52, 53]
    rowResizingState.value = {
      isResizing: true,
      documentId,
      startY: event.clientY,
      startHeight: currentHeight,
      currentHeight,
    } // [cite: 53]

    document.addEventListener('mousemove', handleRowMouseMove) // [cite: 53]
    document.addEventListener('mouseup', stopRowResize) // [cite: 53]
  }

  const handleRowMouseMove = (event: MouseEvent) => {
    if (!rowResizingState.value.isResizing) return // [cite: 53]

    const delta = event.clientY - rowResizingState.value.startY // [cite: 53]
    const newHeight = Math.max(40, rowResizingState.value.startHeight + delta) // [cite: 53]

    rowResizingState.value.currentHeight = newHeight // [cite: 53]

    // Update local document for visual feedback
    const docIndex = documents.value.findIndex(
      (d) => d._id.$oid === rowResizingState.value.documentId // [cite: 54]
    )
    if (docIndex !== -1) {
      const updatedDoc = {
        ...documents.value[docIndex],
        row_height: newHeight,
      } // [cite: 54]
      documents.value.splice(docIndex, 1, updatedDoc) // [cite: 54]
    }
  }

  const stopRowResize = async () => {
    if (!rowResizingState.value.isResizing) return // [cite: 57]
    const { documentId, currentHeight } = rowResizingState.value // [cite: 57]

    rowResizingState.value.isResizing = false // [cite: 57]
    document.removeEventListener('mousemove', handleRowMouseMove) // [cite: 57]
    document.removeEventListener('mouseup', stopRowResize) // [cite: 57]

    if (previewMode.value) {
      const newHeights = {
        ...previewRowHeights.value,
        [documentId]: currentHeight,
      } // [cite: 57]
      sessionStorage.setItem(
        `previewRowHeights-${collectionName.value}`,
        JSON.stringify(newHeights) // [cite: 58]
      )
    } else {
      debouncedRowHeightSave(documentId, currentHeight) // [cite: 58]
    }
  }

  // --- Cell Click/Edit Handling ---
  const handleCellClick = (rowIndex: number, header: string, value: any) => {
    // Value param from original template [cite: 35]
    if (isSaving.value || ['_id', 'created_at', 'updated_at'].includes(header)) return // [cite: 35]

    // Use the original value passed from the template click event
    startEditingCell(rowIndex, header, value) // Use store action [cite: 35]

    // Update selectedCell for visual feedback (Excel-like)
    const actualRowNumber = (currentPage.value - 1) * pageSize.value + rowIndex + 1 // [cite: 35]
    const colIndex = tableHeaders.value.indexOf(header) // [cite: 35]
    selectedCell.value = { colIndex, rowNumber: actualRowNumber } // [cite: 36]

    // Focus logic
    nextTick(() => {
      // Simplified focus selector - adjust if needed [cite: 36]
      const inputElement = scrollContainer.value?.querySelector<
        HTMLInputElement | HTMLTextAreaElement
      >(
        `tr:nth-child(${rowIndex + 1}) td[class*='excel-cell'] textarea, tr:nth-child(${rowIndex + 1}) td[class*='excel-cell'] input` // [cite: 36]
      )
      inputElement?.focus() // [cite: 36]
      if (inputElement && (inputElement.tagName === 'TEXTAREA' || inputElement.type === 'text')) {
        // [cite: 37]
        inputElement.select() // [cite: 37]
      }
    })
  } // Combines original template call [cite: 37] with store logic

  const handleEditBlur = async () => {
    setTimeout(async () => {
      const activeElement = document.activeElement // [cite: 37]
      // Basic check if focus is still within the editing area (might need refinement) [cite: 37]
      const isStillEditing =
        editingCell.value && // [cite: 38]
        activeElement && // [cite: 38]
        (activeElement.closest('.excel-cell-selected') || // [cite: 38]
          activeElement.closest('[data-radix-popper-content-wrapper]')) // Consider Radix poppers for Select [cite: 38]

      if (editingCell.value && !isStillEditing) {
        await saveEdit() // Use store action [cite: 38]
      } else if (!isStillEditing) {
        cancelEdit() // Use store action [cite: 38]
      }
    }, 100) // [cite: 39]
  } // Connects to @blur event [cite: 39]

  // --- Header Editing ---
  const startEditingHeader = (header: string) => {
    editingHeader.value = header // [cite: 60]
    editedShortName.value = shortName(header) // [cite: 60]
  }

  const isEditingHeader = (header: string) => {
    return editingHeader.value === header // [cite: 60]
  }

  const saveShortName = async (header: string) => {
    if (!editedShortName.value.trim()) return // [cite: 60]

    const newShortNames = {
      ...collectionSchema.value.ui?.short_names,
      [header]: editedShortName.value,
    } // [cite: 60]

    try {
      await updateUIMetadata({ short_names: newShortNames }) // [cite: 60]
      editingHeader.value = null // [cite: 61]
    } catch (error) {
      // Handle error [cite: 61]
    }
  }

  const cancelEditTextHead = () => {
    editingHeader.value = null // [cite: 61]
  }

  // --- Column Highlighting ---
  const handleColumnHighlight = (index: number) => {
    // Count hidden columns before the visible index to get the actual index in tableHeaders [cite: 62]
    let hiddenColumnsCount = 0 // [cite: 62]
    for (let i = 0; i <= index; i++) {
      const visibleIndex = i + hiddenColumnsCount // [cite: 62]
      if (
        visibleIndex < tableHeaders.value.length && // [cite: 62]
        hiddenColumns.value.includes(tableHeaders.value[visibleIndex]) // [cite: 62]
      ) {
        hiddenColumnsCount++ // [cite: 63]
        i-- // Stay at the same visible index since we found a hidden column [cite: 63]
      }
    }

    // Adjust index to account for hidden columns
    const adjustedIndex = index + hiddenColumnsCount // [cite: 63]
    const header = tableHeaders.value[adjustedIndex] // [cite: 63]

    // Clear both selected cell and editing state
    selectedCell.value = null // [cite: 63]
    cancelEdit() // This clears editingCell in the store [cite: 63]

    if (selectedRows.value.size > 0) {
      const confirmed = confirm('You have selected rows. Unselect them to highlight the column?') // [cite: 64]

      if (confirmed) {
        resetSelection() // [cite: 64]
        highlightedColumn.value = header // [cite: 64]
      }
    } else {
      if (header === highlightedColumn.value) {
        highlightedColumn.value = null // [cite: 64]
      } else {
        highlightedColumn.value = header // [cite: 64]
      }
    } // [cite: 65]
  }

  const checkClickOutsideHeaders = (event: MouseEvent) => {
    const target = event.target as HTMLElement // [cite: 44]
    const isHeaderClick = target.closest('.excel-column-letter, .excel-column-header') // [cite: 44]
    if (!isHeaderClick) {
      highlightedColumn.value = null // [cite: 45]
    }
  }

  // --- Drag and Drop Columns ---
  function onDragStart(event: DragEvent, visibleIndex: number) {
    const actualIndex = getActualIndex(visibleIndex) // [cite: 66]
    dragState.isDragging = true // [cite: 66]
    dragState.draggedIndex = actualIndex // [cite: 66]
    event.dataTransfer?.setData('text/plain', '') // [cite: 66]
    highlightedColumn.value = tableHeaders.value[actualIndex] // [cite: 66]
  }

  function onDragOver(event: DragEvent, visibleIndex: number) {
    if (!dragState.isDragging) return // [cite: 66]
    event.preventDefault() // [cite: 66]

    const actualIndex = getActualIndex(visibleIndex) // [cite: 66]
    if (dragState.targetIndex !== actualIndex) {
      dragState.targetIndex = actualIndex // [cite: 66]
    }
  }

  function onDrop(event: DragEvent, visibleIndex: number) {
    event.preventDefault() // [cite: 66]
    if (!dragState.isDragging) return // [cite: 67]

    const targetActualIndex = getActualIndex(visibleIndex) // [cite: 67]
    const draggedIndex = dragState.draggedIndex // [cite: 67]

    // Existing column order logic
    const currentUI = collectionSchema.value.ui || {} // [cite: 67, 68]
    let columnOrder = currentUI.columnOrder ? [...currentUI.columnOrder] : [...tableHeaders.value] // [cite: 68]
    const allHeaders = Object.keys(collectionSchema.value.properties || {}) // [cite: 68]

    // Clean and reorder
    columnOrder = columnOrder.filter((h) => allHeaders.includes(h)) // [cite: 68]
    const missing = allHeaders.filter((h) => !columnOrder.includes(h)) // [cite: 68]
    columnOrder.push(...missing) // [cite: 68]

    // Perform the move using actual indices
    const [moved] = columnOrder.splice(draggedIndex, 1) // [cite: 68]
    columnOrder.splice(targetActualIndex, 0, moved) // [cite: 68]

    // Update UI metadata
    updateUIMetadata({ columnOrder }) // [cite: 68]

    // Reset state
    dragState.isDragging = false // [cite: 68]
    dragState.draggedIndex = -1 // [cite: 69]
    dragState.targetIndex = -1 // [cite: 69]
    highlightedColumn.value = null // [cite: 69]
  }

  function onDragEnd() {
    dragState.isDragging = false // [cite: 69]
    dragState.draggedIndex = -1 // [cite: 69]
    dragState.targetIndex = -1 // [cite: 69]
  }

  // --- Context Menu ---
  const handleRightClick = (rowIndex: number, header: string, event: MouseEvent) => {
    event.preventDefault() // [cite: 41]
    selectedCellInfo.value = { rowIndex, header } // [cite: 41]

    // Calculate actual row number and column index for highlighting
    const actualRowNumber = (currentPage.value - 1) * pageSize.value + rowIndex + 1 // [cite: 41]
    const colIndex = tableHeaders.value.indexOf(header) // [cite: 41]
    selectedCell.value = { colIndex, rowNumber: actualRowNumber } // [cite: 41]

    // Position context menu
    const offset = 55 // [cite: 41]
    contextMenuPosition.value = {
      x: event.clientX, // [cite: 42]
      y: event.clientY - offset, // [cite: 42]
    }
    showContextMenu.value = true // [cite: 42]
  }

  const closeContextMenu = () => {
    showContextMenu.value = false // [cite: 42]
    selectedCellInfo.value = null // [cite: 42]
  }

  const pinCell = async () => {
    if (!selectedCellInfo.value) {
      return // [cite: 42]
    }
    if (isSelectedArchived.value) {
      return // [cite: 42]
    }
    // Add check for null user
    if (!user.value) {
      // [cite: 43]
      return // [cite: 43]
    }
    const rowIndex = selectedCellInfo.value.rowIndex // [cite: 43]
    const doc = paginatedDocuments.value[rowIndex] // [cite: 43]
    if (!doc) {
      return // [cite: 43]
    }
    const isPinned = doc.pinned_by?.includes(user.value.id) // [cite: 43]
    try {
      if (isPinned) {
        await unpinDocument(doc._id.$oid) // [cite: 43]
      } else {
        await pinDocument(doc._id.$oid) // [cite: 43]
      }

      // Add this critical line to refresh documents after pin/unpin operation
      await fetchDocuments() // [cite: 44]
    } catch (error) {
      // Error handling without console.error [cite: 44]
    }
    closeContextMenu() // [cite: 44]
  }

  const bookmarkCell = () => {
    if (!selectedCellInfo.value) return // [cite: 44]
    closeContextMenu() // [cite: 44]
  }

  const togglePinStatus = async (docId: string, currentPinStatus: boolean): Promise<void> => {
    try {
      if (currentPinStatus) {
        await unpinDocument(docId) // [cite: 46]
      } else {
        await pinDocument(docId) // [cite: 47]
      }
    } catch (error) {
      // Error handling without console.error [cite: 47]
    }
  }

  // --- Document Navigation/Highlighting ---
  const handleDocumentNavigation = (docId: string) => {
    // Clear existing timeout if any
    if (highlightTimeout) clearTimeout(highlightTimeout) // [cite: 49]

    // Find document index in full dataset
    const index = documents.value.findIndex((doc) => doc._id.$oid === docId) // [cite: 49]
    if (index === -1) return // [cite: 49]

    // Calculate and set correct page
    const page = Math.ceil((index + 1) / pageSize.value) // [cite: 49]
    setPage(page) // [cite: 49]

    // Set highlight and auto-clear after 2s
    highlightedDocumentId.value = docId // [cite: 49, 50]
    highlightTimeout = setTimeout(() => {
      highlightedDocumentId.value = null // [cite: 50]
    }, 2000) // [cite: 50]

    // Scroll to row after DOM update
    nextTick(() => {
      const row = scrollContainer.value?.querySelector(`[data-document-id="${docId}"]`) // [cite: 50]
      if (row) {
        row.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest',
          inline: 'nearest', // [cite: 50]
        })

        // Add visual pulse effect [cite: 51]
        row.classList.add('highlight-pulse') // [cite: 51]
        setTimeout(() => row.classList.remove('highlight-pulse'), 1000) // [cite: 51]
      }
    })
  }

  // --- Template specific handlers ---
  const handleViewChange = (view: string) => {
    changeView(view) // Use store action [cite: 39]
  } // [cite: 39]

  const onPageChange = (page: number) => {
    setPage(page) // Use store action [cite: 39]
  } // [cite: 39]

  const handleDeleteStart = (id: string) => {
    dataTableStore.pendingDeleteId = id // [cite: 39, 40]
  } // [cite: 40]
  const handleDeleteEnd = () => {
    dataTableStore.pendingDeleteId = null // [cite: 40]
  } // [cite: 40]

  // --- Emit events ---
  const emit = defineEmits(['preview-data-update']) // [cite: 71]

  // ==========================================================================
  // Expose (if needed by parent components)
  // ==========================================================================
  defineExpose({
    fetchDocuments: dataTableStore.fetchDocuments, // [cite: 40]
    fetchCollections: dataTableStore.fetchCollections, // [cite: 40]
    setCollection: dataTableStore.setCollection, // [cite: 40]
  })

  const localAllSelected = computed({
    get: () => {
      if (documents.value.length === 0) return false
      return documents.value.every((doc) => selectedRows.value.has(doc._id.$oid))
    },
    set: (val: boolean) => {
      if (val) {
        const ids = documents.value.map((doc) => doc._id.$oid)
        selectedRows.value = new Set(ids)
      } else {
        selectedRows.value.clear()
      }
    },
  })

  const handleScroll = useThrottleFn(async () => {
    if (!scrollContainer.value || isLoading.value || !dataTableStore.hasMore) return

    const { scrollTop, scrollHeight, clientHeight } = scrollContainer.value
    const threshold = 100 // pixels from bottom

    if (scrollHeight - (scrollTop + clientHeight) < threshold) {
      isLoadingMore.value = true
      try {
        await dataTableStore.loadNextPage()
      } finally {
        isLoadingMore.value = false
      }
    }
  }, 200)

  onMounted(() => {
    if (scrollContainer.value) {
      scrollContainer.value.addEventListener('scroll', handleScroll)
    }
  })

  onBeforeUnmount(() => {
    if (scrollContainer.value) {
      scrollContainer.value.removeEventListener('scroll', handleScroll)
    }
  })

  // state for download options
  const showDownloadDialog = ref(false)
  const downloadHeaderChoice = ref<'short' | 'original'>('short')
  const includeId = ref(false) // New include _id option

  const downloadCSV = async () => {
    console.debug('downloadCSV: Handler called')
    showDownloadDialog.value = false
    try {
      // Add include_id parameter to URL
      const url = `${getApiBaseUrl()}/collections/${collectionName.value}/download-csv?headers=${downloadHeaderChoice.value}&include_id=${includeId.value}`
      console.debug('downloadCSV: Fetching from URL:', url)

      const response = await fetch(url, {
        headers: getAuthHeaders(),
      })

      if (!response.ok) throw new Error('Download failed')

      const blob = await response.blob()
      const downloadUrl = window.URL.createObjectURL(blob)

      // Generate dynamic filename
      const now = new Date()
      const timestamp = [
        now.getFullYear(),
        (now.getMonth() + 1).toString().padStart(2, '0'),
        now.getDate().toString().padStart(2, '0'),
        '_',
        now.getHours().toString().padStart(2, '0'),
        now.getMinutes().toString().padStart(2, '0'),
        now.getSeconds().toString().padStart(2, '0'),
      ].join('')

      const headerType =
        downloadHeaderChoice.value === 'short' ? 'short_name_is_used' : 'orig_name_is_used'
      const idSuffix = includeId.value ? '_with_id' : ''

      const filename = `${collectionName.value}_${timestamp}_${headerType}${idSuffix}.csv`

      const a = document.createElement('a')
      a.href = downloadUrl
      a.download = filename
      document.body.appendChild(a)
      a.click()
      window.URL.revokeObjectURL(downloadUrl)
      document.body.removeChild(a)

      // Show success toast
      toast({
        title: 'Download Successful',
        description: 'CSV file downloaded successfully',
        variant: 'default',
      })
    } catch (error) {
      // Error handling and toast
      const message = error instanceof Error ? error.message : 'Unknown error'
      errorMessage.value = `Download failed: ${message}`
      toast({
        title: 'Download Error',
        description: errorMessage.value,
        variant: 'destructive',
      })
    }
  }
</script>
<template>
  <!-- MongoDBDataTable main div -->
  <div
    :class="isSidebarOpen ? 'ml-[280px]' : 'ml-0'"
    class="transition-all duration-300 ease-in-out"
  >
    <MongoDBDataTableNavbar
      :isSplitActive="isSplit"
      class="sticky top-0 z-50"
      :preview-mode="previewMode"
    />
    <div class="excel-container w-full">
      <StickyLeftSidebar
        :isOpen="isSidebarOpen"
        :pinnedDocuments="pinnedDocuments"
        @toggle="isSidebarOpen = !isSidebarOpen"
        @navigate="handleDocumentNavigation"
      />
      <div
        v-if="errorMessage"
        class="fixed top-4 left-4 right-4 z-[9999] mx-4 my-4 p-4 bg-red-100 text-red-700 rounded-lg shadow-xl border-2 border-red-300 break-words"
      >
        {{ errorMessage }}
        <Button
          @click="closeErrorManual"
          variant="ghost"
          size="sm"
          class="absolute right-3 top-3 p-1 h-6 w-6 text-red-700 hover:bg-red-200"
        >
          <Cross2Icon class="h-3 w-3" />
        </Button>
      </div>

      <div
        v-if="isLoading"
        class="flex justify-center my-8"
      >
        <ReloadIcon class="h-8 w-8 animate-spin text-gray-500" />
      </div>

      <div
        ref="scrollContainer"
        class="w-full overflow-auto table-scroll-container"
      >
        <CSVCellReference
          :selectedCell="selectedCell"
          :selectedRows="selectedRows"
          :isSidebarOpen="isSidebarOpen"
          :previewMode="!previewMode"
          @reset-selection=""
        />
        <ExcelCellReference
          :preview-mode="previewMode"
          :is-sidebar-open="isSidebarOpen"
          :selected-cell="selectedCell"
          :selected-rows="selectedRows"
          :collection-name="collectionName"
          :documents="documents"
          :current-page="currentPage"
          :page-size="pageSize"
          :current-view="currentView"
          @document-deleted="fetchDocuments"
          @reset-selection="resetSelection"
          @delete-start="handleDeleteStart"
          @delete-end="handleDeleteEnd"
          @view-change="handleViewChange"
        />
        <!-- Visibility of Columns -->
        <div class="z-40 mt-10 p-2 bg-[#217346]/90 flex gap-2">
          <NavigationMenu>
            <NavigationMenuList>
              <NavigationMenuItem>
                <NavigationMenuTrigger size="sm">Visibility</NavigationMenuTrigger>
                <NavigationMenuContent>
                  <div class="p-2 w-48">
                    <div
                      v-for="header in tableHeaders"
                      :key="header"
                      class="flex items-center space-x-2 py-1 px-2 rounded hover:bg-green-100 transition-colors duration-150 group"
                    >
                      <input
                        type="checkbox"
                        :id="`checkbox-${header}`"
                        :checked="!hiddenColumns.includes(header)"
                        @change="toggleColumnVisibility(header)"
                        class="cursor-pointer accent-green-600"
                      />
                      <label
                        :for="`checkbox-${header}`"
                        class="flex-1 cursor-pointer text-sm group-hover:text-green-800"
                      >
                        {{ collectionSchema.ui?.short_names?.[header] || header }}
                      </label>
                    </div>
                  </div>
                </NavigationMenuContent>
              </NavigationMenuItem>
            </NavigationMenuList>
          </NavigationMenu>

          <div class="flex items-center space-x-2">
            <Switch
              id="preview-live-toggle"
              :modelValue="previewMode"
              :disabled="isImportRoute"
              @update:modelValue="
                (value) => {
                  if (!isImportRoute) previewMode = value
                }
              "
            />
            <Label
              class="text-white cursor-pointer"
              for="preview-live-toggle"
            >
              {{ previewMode ? 'Mode: Preview' : 'Mode: Live' }}
            </Label>
          </div>

          <router-link
            :to="`/collection/${collectionName}/import-csv`"
            class="ml-4"
          >
            <Button
              variant="outline"
              size="sm"
            >
              Link to Import CSV Page
            </Button>
          </router-link>
          <Button
            variant="outline"
            size="sm"
            @click="showDownloadDialog = true"
          >
            Download CSV Data
          </Button>
          <!-- Download Dialog -->
          <Dialog v-model:open="showDownloadDialog">
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Download Options</DialogTitle>
              </DialogHeader>
              <div class="space-y-4">
                <div>
                  <Label>Header Row Format:</Label>
                  <Select v-model="downloadHeaderChoice">
                    <SelectTrigger>
                      <SelectValue placeholder="Select header format" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="short">Short Names</SelectItem>
                      <SelectItem value="original">Original Names</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div class="flex items-center space-x-2">
                  <Switch
                    id="include-id"
                    :modelValue="includeId"
                    @update:modelValue="(value) => (includeId = value)"
                  />
                  <Label
                    for="include-id"
                    class="cursor-pointer"
                  >
                    Include ID
                  </Label>
                </div>
              </div>
              <DialogFooter>
                <Button @click="downloadCSV">Download</Button>
                <Button
                  variant="outline"
                  @click="showDownloadDialog = false"
                  >Cancel</Button
                >
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </div>

        <table
          class="excel-table"
          :style="{ width: `${totalTableWidth}px` }"
        >
          <TableHeader>
            <TableRow class="excel-header-row">
              <TableHead
                class="excel-column-checkbox-selector"
                :style="{
                  width: '40px',
                  minWidth: '40px',
                  maxWidth: '40px',
                }"
              >
                <!-- Select All/Unselect All -->
                <input
                  type="checkbox"
                  :checked="localAllSelected"
                  @change="localAllSelected = !localAllSelected"
                  :disabled="documents.length === 0"
                  class="excel-checkbox"
                />
              </TableHead>

              <TableHead
                class="excel-column-checkbox"
                :style="{
                  width: '30px',
                  minWidth: '30px',
                  maxWidth: '30px',
                }"
              >
                @
              </TableHead>
              <!-- TableHead for column letters -->
              <TableHead
                v-for="(letter, index) in columnLetters"
                :key="`letter-${index}`"
                class="select-none excel-column-letter relative"
                :class="{
                  'drop-target': getActualIndex(index) === dragState.targetIndex,
                  'highlighted-column': highlightedColumn === visibleHeaders[index],
                }"
                @click="handleColumnHighlight(index)"
                draggable="true"
                @dragstart="onDragStart($event, index)"
                @dragover.prevent="onDragOver($event, index)"
                @dragend="onDragEnd"
                @drop="onDrop($event, index)"
                :style="{
                  width:
                    alphaResizingState.isResizing && alphaResizingState.columnIndex === index
                      ? `${alphaResizingState.currentWidth}px`
                      : `${columnWidths[tableHeaders[index]] || 200}px`,
                }"
              >
                <div
                  class="flex items-center justify-center"
                  :class="{
                    // UPDATED condition: Compare with the header from visibleHeaders at the current index
                    'cursor-pointer bg-blue-500 text-white py-[9px] px-3 -mx-[10px] -my-[10px]':
                      highlightedColumn === visibleHeaders[index],
                  }"
                >
                  <span class="excel-letter">{{ letter }}</span>
                  <div
                    class="excel-resizer absolute right-0 top-0"
                    :class="[
                      alphaResizingState.isResizing && alphaResizingState.columnIndex === index
                        ? 'excel-resizer-active'
                        : '',
                    ]"
                    @mousedown="startAlphaResize(index, $event)"
                    @dblclick="resetAlphaColumnWidth(index)"
                  ></div>
                </div>
              </TableHead>
              <TableHead class="excel-column-letter excel-actions-header w-24"> </TableHead>
            </TableRow>
          </TableHeader>
          <TableHeader>
            <TableRow>
              <TableHead
                class="excel-column-checkbox-selector"
                :style="{
                  width: '40px',
                  minWidth: '40px',
                  maxWidth: '40px',
                }"
              >
                ***
              </TableHead>

              <TableHead
                class="excel-row-number-header"
                :style="{
                  width: numberColumnWidth,
                  minWidth: numberColumnWidth,
                  maxWidth: numberColumnWidth,
                }"
              >
                &-
              </TableHead>
              <!-- TableHead for column headers -->
              <TableHead
                v-for="(header, index) in visibleHeaders"
                :key="header"
                class="cursor-pointer excel-column-header font-bold text-black relative"
                :class="{
                  'error-column-header': header === errorColumn && isAdding,
                  'highlighted-column': highlightedColumn === header,
                  dragging: dragState.draggedIndex === getActualIndex(index),
                  'drop-target': dragState.targetIndex === getActualIndex(index),
                }"
                :style="{
                  width:
                    resizingState.isResizing && resizingState.header === header
                      ? `${resizingState.currentWidth}px`
                      : `${columnWidths[header] || 200}px`,
                }"
                @click="handleColumnHighlight(index)"
                draggable="true"
                @dragstart="onDragStart($event, index)"
                @dragover.prevent="onDragOver($event, index)"
                @dragend="onDragEnd"
                @drop="onDrop($event, index)"
              >
                <div class="flex items-center justify-between">
                  <div
                    class="header-content"
                    @dblclick="startEditingHeader(header)"
                  >
                    <span v-if="!isEditingHeader(header)">
                      <!-- Use short name with fallback to header name -->
                      {{ collectionSchema.ui?.short_names?.[header] || header }}
                      <span
                        v-if="isFieldRequired(header)"
                        class="text-red-500"
                        >*</span
                      >
                    </span>
                    <input
                      v-else
                      v-model="editedShortName"
                      @keyup.enter="saveShortName(header)"
                      @keyup.esc="cancelEditTextHead"
                      @blur="saveShortName(header)"
                      class="header-edit-input"
                    />
                  </div>
                  <div
                    class="excel-resizer absolute right-0 top-0"
                    :class="[
                      resizingState.isResizing && resizingState.header === header
                        ? 'excel-resizer-active'
                        : '',
                    ]"
                    @mousedown="startResize(header, $event)"
                    @dblclick="resetColumnWidth(header)"
                  ></div>
                </div>
              </TableHead>
              <TableHead
                class="excel-column-header excel-actions-header select-none"
                :style="{ width: '30px' }"
              >
                Actions
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            <template v-if="documents.length > 0">
              <TableRow
                v-for="(doc, rowIndex) in paginatedDocuments"
                :key="doc._id.$oid"
                :data-document-id="doc._id.$oid"
                :style="{
                  height: previewMode
                    ? `${previewRowHeights[doc._id.$oid] || doc.row_height || 40}px`
                    : `${doc.row_height || 40}px`,
                }"
                class="excel-data-row relative"
                :class="{
                  'highlight-row': highlightedDocumentId === doc._id.$oid,
                  'pending-delete-outline': doc._id.$oid === pendingDeleteId,
                  'selected-row bg-blue-100':
                    selectedRows.has(doc._id.$oid) && doc._id.$oid !== pendingDeleteId,
                }"
              >
                <TableCell
                  class="excel-column-checkbox-selector"
                  :style="{
                    width: '40px',
                    minWidth: '40px',
                    maxWidth: '40px',
                  }"
                >
                  <input
                    type="checkbox"
                    :checked="selectedRows.has(doc._id.$oid)"
                    @change="toggleRow(doc._id.$oid)"
                    class="excel-checkbox"
                  />
                </TableCell>
                <TableCell
                  class="excel-row-number relative"
                  :style="{
                    width: numberColumnWidth,
                    minWidth: numberColumnWidth,
                    maxWidth: numberColumnWidth,
                  }"
                >
                  <div
                    class="w-full h-full flex items-center justify-center cursor-pointer relative"
                    @click.stop="
                      !previewMode &&
                      togglePinStatus(doc._id.$oid, user && doc.pinned_by?.includes(user.id))
                    "
                    :class="[
                      { 'hover:bg-gray-100': !doc.is_archive },
                      { 'cursor-default': previewMode },
                    ]"
                    :title="
                      previewMode
                        ? ''
                        : doc.is_archive
                          ? 'Cannot pin/unpin archived items'
                          : user && doc.pinned_by?.includes(user.id)
                            ? 'Click to unpin'
                            : 'Click to pin'
                    "
                  >
                    <span class="">{{ (currentPage - 1) * pageSize + rowIndex + 1 }}</span>

                    <span
                      v-if="user && doc.pinned_by?.includes(user.id)"
                      class="text-xl left-2 bottom-2 absolute z-10"
                      :class="{ hidden: previewMode }"
                    >
                      ðŸ“Œ
                    </span>
                  </div>

                  <!-- Row resize handle -->
                  <div
                    class="row-resize-handle absolute bottom-[-1px] left-0 right-0 h-2 cursor-row-resize z-10"
                    @mousedown.prevent="startRowResize(doc._id.$oid, $event)"
                  ></div>
                </TableCell>
                <TableCell
                  v-for="header in visibleHeaders"
                  :key="`${doc._id.$oid}-${header}`"
                  class="excel-cell"
                  :class="{
                    'error-column-cell': header === errorColumn,
                    'excel-cell-selected':
                      editingCell?.rowIndex === rowIndex && editingCell?.header === header,
                    'excel-cell-context-selected':
                      selectedCellInfo?.rowIndex === rowIndex &&
                      selectedCellInfo?.header === header,
                    'highlighted-column': highlightedColumn === header,
                    'drop-target': dragState.targetIndex === tableHeaders.indexOf(header),
                  }"
                  @contextmenu.prevent="handleRightClick(rowIndex, header, $event)"
                >
                  <div class="h-full">
                    <div
                      v-if="editingCell?.rowIndex === rowIndex && editingCell?.header === header"
                      class="h-full"
                    >
                      <div
                        v-if="getSchemaInfo(header).bsonType === 'bool'"
                        class="flex items-center justify-center h-full p-2"
                      >
                        <input
                          type="checkbox"
                          v-model="editValue"
                          @change="saveEdit"
                          class="excel-checkbox"
                        />
                      </div>
                      <div
                        v-else-if="isReferenceField(header)"
                        class="p-1"
                      >
                        <Select
                          v-model="editValue"
                          @update:modelValue="saveEdit"
                          class="excel-select"
                        >
                          <SelectTrigger>
                            <SelectValue
                              :placeholder="`Select ${getReferencedCollection(header)}`"
                              :model-value="editValue"
                            />
                          </SelectTrigger>
                          <SelectContent>
                            <ScrollArea class="h-48">
                              <div class="p-1">
                                <Input
                                  v-model="searchQuery[header]"
                                  placeholder="Search..."
                                  class="mb-2 excel-input"
                                />
                                <div
                                  v-if="loadingReferences[getReferencedCollection(header)!]"
                                  class="text-center p-2"
                                >
                                  <ReloadIcon class="h-4 w-4 animate-spin" />
                                </div>
                                <div v-else-if="filteredOptions(header).length">
                                  <SelectItem
                                    v-for="option in filteredOptions(header)"
                                    :key="option.id"
                                    :value="option.id"
                                  >
                                    {{ option.label }}
                                  </SelectItem>
                                </div>
                                <div
                                  v-else
                                  class="text-sm text-gray-500 px-2 py-1"
                                >
                                  No options found
                                </div>
                              </div>
                            </ScrollArea>
                          </SelectContent>
                        </Select>
                      </div>
                      <Input
                        v-else-if="getSchemaInfo(header).bsonType === 'date'"
                        type="datetime-local"
                        v-model="editValue"
                        @blur="handleEditBlur"
                        class="excel-input excel-date-input"
                      />
                      <textarea
                        v-else
                        v-model="editValue"
                        @blur="handleEditBlur"
                        @keyup.ctrl.enter="saveEdit"
                        @keyup.esc="cancelEdit"
                        class="excel-textarea"
                        rows="1"
                      ></textarea>
                    </div>
                    <div
                      v-else
                      class="excel-cell-content"
                      :class="{
                        'excel-cell-editable': !['_id', 'created_at', 'updated_at'].includes(
                          header
                        ),
                        'excel-cell-readonly': ['_id', 'created_at', 'updated_at'].includes(header),
                      }"
                      @click="!previewMode && handleCellClick(rowIndex, header, doc[header])"
                    >
                      <div
                        v-if="getSchemaInfo(header).bsonType === 'bool'"
                        class="flex justify-center"
                      >
                        <input
                          type="checkbox"
                          :checked="doc[header]"
                          disabled
                          class="excel-checkbox"
                        />
                      </div>
                      <div
                        v-else-if="isReferenceField(header)"
                        class="excel-reference-value"
                      >
                        <span v-if="loadingReferences[getReferencedCollection(header)!]">...</span>
                        <span v-else>{{
                          getReferenceLabel(header, doc[header]) || doc[header]
                        }}</span>
                      </div>
                      <template v-else-if="['created_at', 'updated_at'].includes(header)">
                        <span class="excel-timestamp">
                          {{ formatSchemaValue(doc[header], getSchemaInfo(header).bsonType) }}
                        </span>
                      </template>
                      <template v-else-if="header === '_id'">
                        <span>{{ doc[header]?.$oid || doc[header] }}</span>
                      </template>
                      <template v-else>
                        {{ formatSchemaValue(doc[header], getSchemaInfo(header).bsonType) }}
                      </template>
                    </div>
                  </div>
                </TableCell>
                <TableActions
                  :preview-mode="previewMode"
                  :collection-name="collectionName"
                  :document-id="doc._id.$oid"
                  :row-number="(currentPage - 1) * pageSize + rowIndex + 1"
                  @deleted="fetchDocuments"
                  @delete-start="handleDeleteStart"
                  @delete-end="handleDeleteEnd"
                />
                <StickyTableActions
                  :preview-mode="previewMode"
                  :collection-name="collectionName"
                  :document-id="doc._id.$oid"
                  :row-number="(currentPage - 1) * pageSize + rowIndex + 1"
                  :target-ref="scrollContainer"
                  :is-last-row="rowIndex === paginatedDocuments.length - 1"
                  :is-single-row="paginatedDocuments.length === 1"
                  @deleted="fetchDocuments"
                  @delete-start="handleDeleteStart"
                  @delete-end="handleDeleteEnd"
                />
              </TableRow>

              <!-- Context Menu -->
              <div
                v-if="showContextMenu"
                class="fixed z-50 bg-white shadow-lg border rounded-md p-1 min-w-[120px] context-menu"
                :class="{ hidden: previewMode }"
                :style="{
                  left: `${contextMenuPosition.x}px`,
                  top: `${contextMenuPosition.y}px`,
                }"
                @click="closeContextMenu"
              >
                <div
                  class="flex items-center px-3 py-1.5 text-sm rounded-sm relative tooltip-container"
                  :class="[
                    isSelectedArchived
                      ? 'text-gray-400 cursor-not-allowed'
                      : 'hover:bg-gray-100 cursor-pointer text-gray-700',
                  ]"
                  @click="pinCell"
                  @mouseenter="isSelectedArchived && (showPinTooltip = true)"
                  @mouseleave="showPinTooltip = false"
                >
                  <span>
                    <template v-if="selectedDocumentIsPinned">ðŸ“Œ Unpin this item</template>
                    <template v-else>ðŸ“Œ Pin this item</template>
                  </span>
                  <!-- Custom tooltip -->
                  <div
                    v-if="isSelectedArchived && showPinTooltip"
                    class="custom-tooltip absolute bg-gray-800 text-white text-xs rounded py-1 px-2 left-0 bottom-full mb-1 whitespace-nowrap pointer-events-none z-50"
                  >
                    You cannot pin an archived item
                    <div
                      class="tooltip-arrow absolute top-full left-4 w-2 h-2 bg-gray-800 transform rotate-45"
                    ></div>
                  </div>
                </div>
                <div
                  class="flex items-center px-3 py-1.5 text-sm hover:bg-gray-100 rounded-sm cursor-pointer"
                  @click="bookmarkCell"
                >
                  ðŸ”– Bookmark
                </div>
              </div>

              <!-- End of Context Menu -->
            </template>

            <TableRow
              v-if="isAdding"
              class="excel-new-row"
              :class="['excel-new-row', { 'excel-new-row-error': addingRowError }]"
            >
              <TableCell
                class="excel-column-checkbox-selector"
                :style="{
                  width: '40px',
                  minWidth: '40px',
                  maxWidth: '40px',
                }"
              >
                <input
                  type="checkbox"
                  disabled
                  class="excel-checkbox"
                />
              </TableCell>
              <TableCell class="excel-row-number"> {{ documents.length + 1 }} </TableCell>
              <TableCell
                v-for="header in tableHeaders"
                :key="`new-${header}`"
                class="excel-cell"
                :class="{
                  'error-column-cell': header === errorColumn,
                  'highlighted-column': highlightedColumn === header,
                }"
              >
                <span
                  v-if="['created_at', 'updated_at'].includes(header)"
                  class="excel-timestamp"
                >
                  (auto-generated)
                </span>

                <div
                  v-else-if="header !== '_id' && getSchemaInfo(header).bsonType === 'bool'"
                  class="flex items-center justify-center"
                >
                  <input
                    type="checkbox"
                    v-model="newDocument[header]"
                    class="excel-checkbox"
                  />
                </div>
                <div
                  v-else-if="header !== '_id' && isReferenceField(header)"
                  class="h-8"
                >
                  <Select
                    v-model="newDocument[header]"
                    class="excel-select"
                  >
                    <SelectTrigger class="h-8">
                      <SelectValue :placeholder="`Select`" />
                    </SelectTrigger>
                    <SelectContent>
                      <div
                        v-if="loadingReferences[getReferencedCollection(header)!]"
                        class="p-2"
                      >
                        <ReloadIcon class="h-4 w-4 animate-spin mx-auto" />
                      </div>
                      <ScrollArea
                        v-else
                        class="h-48"
                      >
                        <Input
                          v-model="searchQuery[header]"
                          placeholder="Search..."
                          class="mb-1 mx-1 excel-input"
                        />
                        <SelectItem
                          v-for="option in filteredOptions(header)"
                          :key="option.id"
                          :value="option.id"
                        >
                          {{ option.label }}
                        </SelectItem>
                      </ScrollArea>
                    </SelectContent>
                  </Select>
                </div>
                <Input
                  v-else-if="header !== '_id'"
                  v-model="newDocument[header]"
                  :type="getSchemaInfo(header).bsonType === 'date' ? 'datetime-local' : 'text'"
                  class="excel-input"
                  :class="{ 'ring-2 ring-red-500': header === errorColumn }"
                />
                <span
                  v-else
                  class="excel-auto-id"
                  >(auto)</span
                >
              </TableCell>
              <TableCell class="excel-cell text-center">
                <Button
                  variant="ghost"
                  @click="saveNewDocument"
                  size="sm"
                  class="px-0 -ml-1"
                  :disabled="isSaving"
                >
                  <ReloadIcon
                    v-if="isSaving"
                    class="h-4 w-4 animate-spin"
                  />
                  <span v-else>ðŸ’¾</span>
                </Button>
              </TableCell>
            </TableRow>

            <TableRow
              v-if="!isAdding && !previewMode"
              class="excel-add-row"
              @click="startAdding"
            >
              <TableCell
                :colspan="tableHeaders.length + 3"
                class="excel-add-cell"
              >
                <div class="inline-flex items-center gap-2 excel-add-button">
                  <PlusCircledIcon class="h-4 w-4" />
                  <span class="text-sm">
                    {{ documents.length === 0 ? 'Add first document' : 'Add new document' }}
                  </span>
                </div>
              </TableCell>
            </TableRow>
          </TableBody>
        </table>

        <div
          v-if="isAdding"
          class="sticky top-2 left-2 z-20 p-3 shadow-lg flex items-center space-x-2 w-auto rounded-md bg-green-50"
        >
          <Button
            @click="saveNewDocument"
            size="sm"
            class="bg-green-600 hover:bg-green-700 text-white"
            :disabled="isSaving"
          >
            <ReloadIcon
              v-if="isSaving"
              class="w-4 h-4 animate-spin"
            />
            <PlusCircledIcon
              v-else
              class="w-4 h-4 mr-1"
            />
            Save
          </Button>
          <Button
            @click="cancelAdding"
            variant="outline"
            size="sm"
            class="border-green-600 text-green-700 hover:bg-green-100"
            :disabled="isSaving"
          >
            <Cross2Icon class="w-4 h-4 mr-1" /> Cancel
          </Button>
        </div>

        <!-- Loading indicator -->
        <div
          v-if="isLoadingMore"
          class="loading-indicator"
        >
          <ReloadIcon class="h-6 w-6 animate-spin text-gray-500" />
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
  .loading-indicator {
    display: flex;
    justify-content: center;
    padding: 1rem;
  }
  .pending-delete-outline {
    background-color: #fee2e2;
    border: 2px solid #ef4444;
    color: #991b1b;
  }
  /* drag state */
  .dragging {
    opacity: 0.6;
    cursor: grabbing;
    background: rgba(33, 150, 243, 0.1);
  }

  .drop-target {
    position: relative;
    border-right: 2px solid #d0d0d0; /* Light gray */
  }
  .drop-target::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    width: 0;
    border-right: 8px solid #d0d0d0; /* Same light gray */
    right: -4px;
  }

  /* highlight for entire column */
  .highlighted-column {
    position: relative;
    outline: none;
    box-shadow:
      1px 0 0 0 #2196f3,
      -1px 0 0 0 #2196f3;
    z-index: 2;
    background-color: rgba(33, 150, 243, 0.05) !important;
  }

  .highlighted-column::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    right: -2px;
    width: 2px;
    background-color: #2196f3;
    z-index: 3;
  }

  /* column table head inline edit */
  .header-edit-input {
    @apply px-1 py-0 border border-blue-300 rounded;
  }
  .header-content {
    min-width: 100px;
  }

  .row-resize-handle {
    background-color: transparent;
    transition: background-color 0.2s;
  }

  .row-resize-handle:hover {
    background-color: #3b82f6;
  }

  .excel-data-row:hover .row-resize-handle {
    background-color: #3b82f666;
  }

  .highlight-row {
    position: relative;
    animation: highlight-fade 2s forwards;
    box-shadow: 0 0 0 2px #fde047; /* Outline yellow */
    outline: 2px solid #fde047; /* Same as box shadow */
    background-color: #fff9c4; /* Lighter yellow background */
  }

  @keyframes highlight-fade {
    0% {
      box-shadow: 0 0 0 3px #fde047;
    }
    70% {
      box-shadow: 0 0 0 3px #fde047;
    }
    100% {
      box-shadow: 0 0 0 3px transparent;
    }
  }

  .highlight-pulse {
    animation: pulse-highlight 1s ease-in-out;
  }

  @keyframes pulse-highlight {
    0% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.02);
    }
    100% {
      transform: scale(1);
    }
  }

  /* Context Menu */
  .tooltip-container {
    position: relative;
  }

  .custom-tooltip {
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    animation: fadeIn 0.2s ease-in-out;
  }

  .tooltip-arrow {
    position: absolute;
    top: 100%;
    left: 10px;
    margin-top: -4px;
    width: 8px;
    height: 8px;
    transform: rotate(45deg);
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  .excel-cell-context-selected {
    outline: 2px solid #217346;
    outline-offset: -2px;
    position: relative;
    z-index: 1;
    overflow: visible;
  }

  .context-menu {
    transform: translateY(-100%); /* Move menu up by its own height */
    pointer-events: auto; /* Ensure menu remains interactive */
  }

  /* small arrow */
  .context-menu::before {
    content: '';
    position: absolute;
    top: -5px; /* Change from bottom to top */
    left: 10px;
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-bottom: 5px solid white; /* Change from border-top to border-bottom */
    filter: drop-shadow(0 -1px 1px rgba(0, 0, 0, 0.1)); /* Adjust shadow direction */
  }

  /* --- Style Section (From old_codes.txt, using <style scoped>) --- */
  .selected-row {
    outline: 2px solid #2196f3; /* [cite: 84] */
    border: 2px solid #2196f3; /* [cite: 85] */
    outline-offset: -1px;
    position: relative;
  }

  .bg-red-100 {
    /* Style for pending delete row */
    outline: none !important; /* [cite: 85] */
  }

  /* Excel-inspired container */
  .excel-container {
    font-family: 'Segoe UI', Arial, sans-serif; /* [cite: 86] */
    border: 1px solid #d4d4d8; /* [cite: 86] */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05); /* [cite: 87] */
    border-radius: 2px;
    background-color: #ffffff; /* [cite: 87] */
  }

  /* Excel table styling */
  .excel-table {
    table-layout: fixed; /* [cite: 88] */
    min-width: fit-content; /* [cite: 88] */
    border-collapse: collapse; /* Add this */
  }

  /* Excel header row */
  .excel-header-row {
    background-color: #f3f3f3; /* [cite: 88] */
  }

  /* Excel column headers */
  .excel-column-header {
    transition:
      background 0.2s,
      opacity 0.2s;
    background-color: #f3f3f3; /* [cite: 89] */
    border: 1px solid #d0d0d0; /* [cite: 89] */
    padding: 6px 8px; /* [cite: 89] */
    font-weight: 600; /* [cite: 89] */
    font-size: 14px; /* [cite: 89] */
    color: #000000; /* [cite: 90] */
    position: relative; /* [cite: 90] */
    text-align: left; /* [cite: 90] */
    height: 32px; /* Added height */
    box-sizing: border-box; /* Added box-sizing */
    vertical-align: middle; /* Center vertically */
  }

  /* Excel column letter headers (A, B, C) */
  .excel-column-letter {
    background-color: #e6e6e6; /* [cite: 90] */
    border: 1px solid #d0d0d0; /* [cite: 91] */
    padding: 4px 8px; /* [cite: 91] */
    font-weight: 600; /* [cite: 91] */
    font-size: 14px; /* [cite: 91] */
    color: #616161; /* [cite: 91] */
    text-align: center; /* [cite: 91] */
    height: 28px; /* Added height */
    box-sizing: border-box; /* Added box-sizing */
    vertical-align: middle; /* Center vertically */
  }

  /* Update sticky positioning for new column */
  .excel-column-checkbox-selector {
    position: sticky; /* [cite: 92] */
    left: 0; /* [cite: 92] */
    z-index: 5; /* [cite: 92] */
    background-color: #f3f3f3; /* [cite: 92] */ /* Match header */
    border: 1px solid #d0d0d0; /* Added border */
    text-align: center; /* Center checkbox */
    vertical-align: middle; /* Center checkbox */
    box-sizing: border-box;
  }
  /* Need background for sticky cells in body */
  .excel-data-row .excel-column-checkbox-selector {
    background-color: #ffffff; /* White for data rows */
  }
  .excel-data-row:hover .excel-column-checkbox-selector {
    background-color: #edf5fd; /* Match row hover */
  }
  .excel-data-row.selected-row .excel-column-checkbox-selector {
    background-color: #ebf8ff; /* Match selected row (adjust color) */
  }
  .excel-data-row.bg-red-100 .excel-column-checkbox-selector {
    background-color: #fee2e2; /* Match delete row */
  }

  /* Adjust row number positioning */
  .excel-row-number-header {
    /* Applied to TH */
    position: sticky; /* [cite: 98, 100] */
    left: 40px; /* [cite: 98, 101] */ /* Match selector width */
    z-index: 4; /* [cite: 99, 101] */
    background-color: #f3f3f3; /* [cite: 99, 101] */
    border: 1px solid #d0d0d0; /* [cite: 100, 102] */
    /* outline: 1px solid #d0d0d0; */ /* [cite: 100, 103] Outline removed, use border */
    text-align: center; /* Center text */
    vertical-align: middle; /* Center text */
    box-sizing: border-box;
    width: 30px !important; /* [cite: 124] */
    min-width: 30px !important; /* [cite: 124] */
    max-width: 30px !important; /* [cite: 124] */
    padding: 6px 0px; /* Adjust padding */
    font-weight: 600; /* [cite: 97] */
    font-size: 14px; /* [cite: 97] */
    color: #616161; /* [cite: 97] */
  }
  .excel-row-number {
    /* Applied to TD */
    position: sticky; /* [cite: 104] */
    left: 40px; /* [cite: 104] */ /* Match selector width */
    z-index: 2; /* [cite: 105] */
    background-color: #f3f3f3; /* [cite: 105] */
    border: 1px solid #d0d0d0; /* [cite: 105] */
    /* outline: 1px solid #d0d0d0; */ /* [cite: 106] Outline removed, use border */
    text-align: center;
    vertical-align: middle;
    box-sizing: border-box;
    width: 30px !important; /* [cite: 124] */
    min-width: 30px !important; /* [cite: 124] */
    max-width: 30px !important; /* [cite: 124] */
    font-size: 14px; /* Match headers */
    color: #616161; /* Match headers */
  }
  /* Hover state for row numbers */
  .excel-data-row:hover .excel-row-number {
    background-color: #edf5fd; /* [cite: 140] */ /* Match row hover color */
  }
  .excel-data-row.selected-row .excel-row-number {
    background-color: #ebf8ff; /* Match selected row (adjust color) */
  }
  .excel-data-row.bg-red-100 .excel-row-number {
    background-color: #fee2e2; /* Match delete row */
  }

  /* Original selector column TH style (no longer needed?) */
  /* .excel-column-checkbox {
  position: sticky; [cite: 95]
  left: 40px; [cite: 95]
  z-index: 4; [cite: 95]
  background-color: #e6e6e6; [cite: 96]
  border: 1px solid #d0d0d0; [cite: 96]
  padding: 4px 8px; [cite: 96]
  font-weight: 600; [cite: 97]
  font-size: 14px; [cite: 97]
  color: #616161; [cite: 97]
  text-align: center; [cite: 97]
  outline: 1px solid #d0d0d0; [cite: 97]
} */

  .excel-letter {
    font-weight: 700; /* [cite: 97] */
  }

  /* Excel actions header */
  .excel-actions-header {
    /* Applied to TH */
    background-color: #f3f3f3; /* [cite: 106] */
    border: 1px solid #d0d0d0; /* [cite: 106] */
    text-align: center; /* [cite: 106] */
    position: sticky; /* Added sticky */
    right: 0; /* Added sticky */
    z-index: 4; /* Added sticky */
    width: 60px !important; /* [cite: 125] */
    min-width: 60px !important; /* [cite: 125] */
    max-width: 60px !important; /* [cite: 125] */
    box-sizing: border-box;
    vertical-align: middle;
  }
  .excel-actions-cell {
    /* Applied to TD */
    border: 1px solid #d0d0d0;
    position: sticky; /* Added sticky */
    right: 0; /* Added sticky */
    z-index: 2; /* Added sticky */
    width: 60px !important; /* [cite: 125] */
    min-width: 60px !important; /* [cite: 125] */
    max-width: 60px !important; /* [cite: 125] */
    background-color: #ffffff; /* Need background for sticky */
    text-align: center;
    vertical-align: middle;
    box-sizing: border-box;
  }
  /* Hover/Selected states for actions cell */
  .excel-data-row:hover .excel-actions-cell {
    background-color: #edf5fd; /* Match row hover */
  }
  .excel-data-row.selected-row .excel-actions-cell {
    background-color: #ebf8ff; /* Match selected row (adjust color) */
  }
  .excel-data-row.bg-red-100 .excel-actions-cell {
    background-color: #fee2e2; /* Match delete row */
  }

  /* Excel data rows */
  .excel-data-row:hover {
    background-color: #edf5fd; /* [cite: 107] */
  }

  /* Excel data cell */
  .excel-cell {
    border: 1px solid #d0d0d0; /* [cite: 107] */
    padding: 0; /* [cite: 108] */ /* Reset padding for inputs */
    font-size: 14px; /* [cite: 108] */
    color: #212121; /* [cite: 108] */
    position: relative; /* [cite: 108] */
    height: 40px; /* [cite: 108, 116] */ /* Set consistent height */
    box-sizing: border-box; /* Add box-sizing */
    vertical-align: middle; /* Center content */
    overflow: hidden; /* Hide overflow */
    white-space: nowrap; /* Prevent wrapping */
    text-overflow: ellipsis; /* Add ellipsis */
  }
  .excel-cell div {
    /* Ensure divs within cells allow vertical centering */
    display: flex;
    align-items: center;
    height: 100%;
  }

  /* Excel cell content */
  .excel-cell-content {
    padding: 6px 8px; /* [cite: 109] */ /* Restore padding for read-only */
    min-height: 40px; /* [cite: 109] */
    width: 100%; /* Ensure it fills cell */
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    display: block; /* Override flex from div rule */
  }

  /* Excel cell editable */
  .excel-cell-editable {
    cursor: pointer; /* [cite: 110] */
  }

  .excel-cell-editable:hover {
    background-color: #e8f3fd; /* [cite: 110] */
  }

  /* Excel cell readonly */
  .excel-cell-readonly {
    cursor: not-allowed; /* [cite: 111] */
    opacity: 0.8; /* [cite: 111] */
    background-color: #f9f9f9; /* [cite: 111] */
  }

  /* Excel cell selected - active cell styling */
  .excel-cell-selected {
    outline: 2px solid #217346; /* [cite: 112] */
    outline-offset: -2px; /* [cite: 112] */
    position: relative; /* [cite: 112] */
    z-index: 1; /* [cite: 113] */
    overflow: visible; /* Allow input to overflow slightly if needed */
  }

  /* Excel textarea */
  .excel-textarea {
    width: 100%; /* [cite: 113] */
    height: 100%; /* [cite: 113] */
    padding: 6px 8px; /* [cite: 113] */
    font-family: 'Segoe UI', Arial, sans-serif; /* [cite: 113] */
    font-size: 14px; /* [cite: 114] */
    border: none; /* [cite: 114] */
    resize: none; /* [cite: 114] */
    min-height: 40px; /* [cite: 114] */
    outline: none; /* [cite: 115] */
    box-shadow: none; /* [cite: 115] */
    overflow: hidden; /* [cite: 115] */
    box-sizing: border-box; /* Added */
    background-color: white; /* Ensure background */
    vertical-align: top; /* Align text top */
  }

  /* Excel input */
  .excel-input {
    height: 100%; /* [cite: 118] */
    width: 100%; /* Added */
    min-height: 32px; /* [cite: 118] */ /* Ensure min height */
    border-radius: 0; /* [cite: 118] */
    border: none; /* [cite: 119] */
    box-shadow: none; /* [cite: 119] */
    font-size: 14px; /* [cite: 119] */
    padding: 4px 6px; /* [cite: 119] */
    outline: none; /* Added */
    box-sizing: border-box; /* Added */
    background-color: white; /* Ensure background */
  }

  .excel-input:focus-visible {
    outline: none; /* [cite: 119] */
    box-shadow: none; /* [cite: 120] */
    border: none; /* [cite: 120] */
    /* ring: none; */ /* [cite: 120] */ /* Removed ring */
  }

  /* Excel date input */
  .excel-date-input {
    padding: 2px 4px; /* [cite: 120] */
    font-size: 14px; /* [cite: 120] */
  }

  /* Excel checkbox */
  .excel-checkbox {
    height: 16px; /* [cite: 120] */
    width: 16px; /* [cite: 121] */
    cursor: pointer; /* [cite: 121] */
    accent-color: #217346; /* [cite: 121] */
    vertical-align: middle; /* Align checkbox */
  }

  /* Excel reference value */
  .excel-reference-value {
    color: #0066cc; /* [cite: 121] */
    cursor: pointer; /* [cite: 121] */
    text-decoration: underline; /* Added underline */
  }

  /* Excel timestamp value */
  .excel-timestamp {
    color: #666666; /* [cite: 122] */
    font-style: italic; /* [cite: 122] */
    font-size: 12px; /* [cite: 122] */ /* Slightly smaller */
    display: block; /* Ensure it takes space */
    line-height: normal; /* Reset line height */
  }

  /* Excel auto ID */
  .excel-auto-id {
    color: #888888; /* [cite: 123] */
    font-style: italic; /* [cite: 123] */
    padding: 0 8px; /* [cite: 123] */
    font-size: 12px; /* [cite: 123] */ /* Slightly smaller */
    display: block;
    line-height: normal;
  }

  /* Excel new row */
  .excel-new-row {
    background-color: #e8f5e9; /* [cite: 126] */
  }
  .excel-new-row .excel-cell {
    height: 40px; /* [cite: 116] */
    overflow: visible; /* [cite: 116] */ /* Allow select dropdown */
    vertical-align: middle; /* Center vertically */
  }
  .excel-new-row .excel-input {
    overflow: hidden; /* [cite: 117] */
    height: 100%; /* Ensure input fills cell */
    background-color: white;
    border: 1px solid #d0d0d0; /* Add border for clarity */
  }
  .excel-new-row .excel-select > button {
    /* Target trigger */
    height: 100%;
    background-color: white;
    border: 1px solid #d0d0d0;
  }

  /* Excel cancel button (if used) */
  .excel-cancel-button {
    color: #666666; /* [cite: 126] */
    font-size: 14px; /* [cite: 126] */
    height: 28px; /* [cite: 127] */
  }

  /* Excel add row */
  .excel-add-row {
    cursor: pointer; /* [cite: 127] */
  }

  .excel-add-row:hover {
    background-color: #f0f8ff; /* [cite: 127] */
  }

  /* Excel add cell */
  .excel-add-cell {
    text-align: left; /* [cite: 128] */ /* Changed from center */
    padding: 8px 8px; /* [cite: 128] */ /* Adjusted padding */
    border-top: 1px solid #d0d0d0; /* Add border */
  }

  /* Excel add button */
  .excel-add-button {
    color: #217346; /* [cite: 129] */
    font-weight: 500; /* [cite: 129] */
  }

  /* Excel column resizer */
  .excel-resizer {
    width: 5px; /* [cite: 129] */
    height: 100%; /* [cite: 130] */
    cursor: col-resize; /* [cite: 130] */
    position: absolute; /* [cite: 130] */
    right: 0; /* [cite: 130] */
    top: 0; /* [cite: 130] */
    background-color: transparent; /* [cite: 130] */
    z-index: 10; /* Ensure above cell content */
  }

  .excel-resizer:hover {
    background-color: #93c5fd; /* [cite: 130] */ /* Lighter blue */
  }

  .excel-resizer-active {
    background-color: #3b82f6 !important; /* [cite: 131] */ /* Brighter blue */
  }

  /* Excel select */
  .excel-select {
    font-size: 14px; /* [cite: 131] */
    width: 100%; /* Ensure select fills space */
  }
  /* Style trigger specifically */
  .excel-select > button {
    height: 100%;
    border-radius: 0;
    border: none; /* Remove trigger border in view mode */
    padding: 6px 8px;
    box-sizing: border-box;
    justify-content: space-between; /* Align icon right */
    background-color: transparent;
  }
  .excel-cell-selected .excel-select > button {
    border: 2px solid #217346; /* Add border only when selected */
    background-color: white;
  }

  /* Excel pagination */
  .excel-pagination {
    margin-top: 16px; /* [cite: 133] */
    padding: 8px; /* [cite: 133] */
    border-top: 1px solid #e0e0e0; /* [cite: 133] */
    display: flex; /* [cite: 133] */
    justify-content: center; /* [cite: 133] */
  }

  .excel-pagination-button {
    color: #217346; /* [cite: 134] */
    /* Add other button styling if needed */
  }

  /* Excel footer */
  .excel-footer {
    display: flex; /* [cite: 134] */
    align-items: center; /* [cite: 134] */
    gap: 16px; /* [cite: 134] */ /* Increased gap */
    padding: 8px 16px; /* [cite: 134] */
    border-top: 1px solid #e0e0e0; /* [cite: 135] */
    background-color: #f9f9f9; /* [cite: 135] */
  }

  .excel-page-size-label {
    font-size: 14px; /* [cite: 135] */
    color: #666666; /* [cite: 135] */
  }

  .excel-page-size-select {
    font-size: 14px; /* [cite: 135] */
  }

  .excel-status-info {
    margin-left: auto; /* [cite: 136] */ /* Push to right */
    font-size: 14px; /* [cite: 136] */
    color: #666666; /* [cite: 136] */
  }

  .error-column-header {
    background-color: #fee2e2 !important; /* [cite: 136] */
    border: 1px solid #ef4444 !important; /* [cite: 136] */ /* Changed border width */
  }

  .error-column-cell {
    /* Applied to TD in add row */
    background-color: #fef2f2 !important; /* [cite: 137] */
    /* Removed border here, applied to input instead */
    /* animation: error-flash 5s; */ /* [cite: 137] */ /* Removed animation */
  }
  .excel-new-row .error-column-cell .excel-input {
    /* Target input in error cell */
    border: 1px solid #ef4444 !important;
    outline: 1px solid #ef4444 !important;
  }

  .excel-new-row-error {
    /* Applied to the TR for adding */
    background-color: #fee2e2 !important; /* [cite: 138] */
    /* animation: error-flash 5s; */ /* [cite: 138] */ /* Removed animation */
  }
  /* Flash effect was removed as it might be jarring */
  /* @keyframes error-flash { ... } */ /**/

  /* Sticky Header Adjustments */
  /* Ensure data headers stay below the numbering column header */
  .excel-column-header {
    position: sticky; /* [cite: 138] */
    top: 28px; /* [cite: 139] */ /* Height of alpha header */
    z-index: 3; /* [cite: 139] */
  }
  /* Adjust z-index for the column letters header */
  .excel-header-row th {
    /* Target TH in alpha row */
    position: sticky;
    top: 0;
    z-index: 5; /* [cite: 139] */
  }
  /* Override z-index for specific sticky headers in alpha row */
  .excel-header-row .excel-column-checkbox-selector {
    z-index: 6;
    background-color: #e6e6e6;
  }
  .excel-header-row .excel-column-checkbox {
    z-index: 5;
    background-color: #e6e6e6;
  } /* Row number in alpha */
  .excel-header-row .excel-actions-header {
    z-index: 5;
    background-color: #e6e6e6;
  }

  /* Add green scrollbar to the table container */
  .table-scroll-container::-webkit-scrollbar {
    height: 16px; /* [cite: 141] */
    width: 12px; /* Added width */
    background-color: #f0fdf4; /* [cite: 141] */
  }

  .table-scroll-container::-webkit-scrollbar-track {
    background: #f0fdf4; /* [cite: 142] */
    border-radius: 10px; /* [cite: 142] */
  }

  .table-scroll-container::-webkit-scrollbar-thumb {
    background: #16a34a; /* [cite: 142] */
    border-radius: 10px; /* [cite: 142] */
    border: 2px solid #f0fdf4; /* [cite: 142] */
  }

  .table-scroll-container::-webkit-scrollbar-thumb:hover {
    background: #22c55e; /* [cite: 143] */
  }

  /* Ensure sticky backgrounds cover content */
  th,
  td {
    background-clip: padding-box; /* Prevents background from going under border */
  }
</style>


// src/services/documentService.ts

import { AUTH_CONSTANTS } from '@/constants/auth'
import { getApiBaseUrl } from '@/utils/api'

interface ApiResponse<T> {
  success: boolean
  data?: T
  error?: string
}

export const documentService = {
  // Get the authentication token from localStorage
  getAuthToken(): string | null {
    return localStorage.getItem(AUTH_CONSTANTS.TOKEN_KEY)
  },
  // Create authentication headers for API requests
  getAuthHeaders(): HeadersInit {
    const token = this.getAuthToken()
    if (!token) {
      console.warn('No authentication token available')
      return {
        'Content-Type': 'application/json',
      }
    }

    return {
      'Content-Type': 'application/json',
      Authorization: `${AUTH_CONSTANTS.TOKEN_PREFIX} ${token}`,
    }
  },

  async fetchCollections(): Promise<ApiResponse<string[]>> {
    try {
      const response = await fetch(`${getApiBaseUrl()}/collections`)

      if (!response.ok) {
        throw new Error(`API returned ${response.status}: ${response.statusText}`)
      }

      return (await response.json()) as ApiResponse<string[]>
    } catch (error) {
      console.error('Error fetching collections:', error)
      return {
        success: false,
        error: `Failed to load collections: ${error}`,
      }
    }
  },

  async deleteDocument(collectionName: string, documentId: string) {
    const response = await fetch(
      `${getApiBaseUrl()}/collections/${collectionName}/documents/${documentId}`,
      { method: 'DELETE' }
    )
    return response.json()
  },

  // documentService.ts

  async pinDocument(collectionName: string, documentId: string) {
    console.log(
      `documentService.pinDocument: Starting API call for ${collectionName}/${documentId}`
    )
    try {
      const url = `${getApiBaseUrl()}/collections/${collectionName}/documents/${documentId}/pin`
      console.log(`documentService.pinDocument: Sending PUT request to ${url}`)

      const response = await fetch(url, {
        method: 'PUT',
        headers: this.getAuthHeaders(),
      })

      console.log(`documentService.pinDocument: Received response with status ${response.status}`)

      if (!response.ok) {
        console.error(
          `documentService.pinDocument: HTTP error ${response.status}: ${response.statusText}`
        )
      }

      const data = await response.json()
      console.log(`documentService.pinDocument: Parsed response data`, data)
      return data
    } catch (error) {
      console.error('documentService.pinDocument: Error occurred:', error)
      throw error
    }
  },

  async unpinDocument(collectionName: string, documentId: string) {
    console.log(
      `documentService.unpinDocument: Starting API call for ${collectionName}/${documentId}`
    )
    try {
      const url = `${getApiBaseUrl()}/collections/${collectionName}/documents/${documentId}/unpin`
      console.log(`documentService.unpinDocument: Sending PUT request to ${url}`)

      const response = await fetch(url, {
        method: 'PUT',
        headers: this.getAuthHeaders(),
      })

      console.log(`documentService.unpinDocument: Received response with status ${response.status}`)

      if (!response.ok) {
        console.error(
          `documentService.unpinDocument: HTTP error ${response.status}: ${response.statusText}`
        )
      }

      const data = await response.json()
      console.log(`documentService.unpinDocument: Parsed response data`, data)
      return data
    } catch (error) {
      console.error('documentService.unpinDocument: Error occurred:', error)
      throw error
    }
  },
}


// src/store/dataTableStore.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { useToast } from '@/components/ui/toast/use-toast'
import { getApiBaseUrl } from '@/utils/api'
import { documentService } from '@/services/documentService'
import { useDebounceFn } from '@vueuse/core'
const API_BASE = getApiBaseUrl()

// Define the structure of a document (adjust based on your actual data)
interface Document {
  _id: { $oid: string }
  [key: string]: any // Allow other properties
}

// Define the structure for reference options
interface ReferenceOption {
  id: string
  label: string
}

export const useDataTableStore = defineStore('dataTable', () => {
  const previewMode = ref(sessionStorage.getItem('previewMode') === 'true')
  const { toast } = useToast()

  // --- State ---
  const collectionName = ref<string>('users') // Default collection
  const documents = ref<Document[]>([])
  const collectionSchema = ref<any>({}) // Consider defining a stricter type
  const isLoading = ref<boolean>(false)
  const errorMessage = ref<string>('')
  const pageSize = ref<number>(20)
  const currentPage = ref<number>(1)
  const hasMore = ref<boolean>(true)
  const filterQuery = ref<string>('{}') // Keep filter query local or move if needed globally
  const newDocument = ref<Record<string, any>>({})
  const isAdding = ref<boolean>(false)
  const editingCell = ref<{ rowIndex: number; header: string } | null>(null)
  const editValue = ref<any>('') // Can be string, boolean, etc.
  const isSaving = ref<boolean>(false)
  const selectedRows = ref<Set<string>>(new Set())
  const currentView = ref<string>('empty-or-recovered') // e.g., "all", "archives"
  const pendingDeleteId = ref<string | null>(null)
  const referenceOptions = ref<Record<string, ReferenceOption[]>>({})
  const loadingReferences = ref<Record<string, boolean>>({})
  const collectionsList = ref<string[]>([])
  const errorColumn = ref<string | null>(null) // For highlighting duplicate errors
  const addingRowError = ref<boolean>(false)

  // --- Getters (Computed) ---
  const totalDocuments = ref<number>(0)
  const totalPages = computed(() => Math.ceil(totalDocuments.value / pageSize.value))

  const paginatedDocuments = computed(() => {
    const start = (currentPage.value - 1) * pageSize.value
    const end = start + pageSize.value
    return documents.value.slice(start, end)
  })

  const tableHeaders = computed(() => {
    if (!collectionSchema.value.properties) return []
    const props = collectionSchema.value.properties
    const keys = Object.keys(props)

    if (collectionSchema.value.ui?.columnOrder) {
      const columnOrder = collectionSchema.value.ui.columnOrder
      // Filter valid headers and add missing ones
      const ordered = columnOrder.filter((key: string) => keys.includes(key))
      const remaining = keys.filter((key: string) => !columnOrder.includes(key))
      return [...ordered, ...remaining]
    }

    return keys.sort((a, b) => {
      const required = collectionSchema.value.required || []
      if (required.includes(a) && !required.includes(b)) return -1
      if (!required.includes(a) && required.includes(b)) return 1
      if (a === '_id') return -1
      if (b === '_id') return 1
      return a.localeCompare(b)
    })
  })

  const columnWidths = computed(() => {
    return collectionSchema.value?.ui?.columnWidths || {}
  })

  const allSelected = computed({
    get: () => totalDocuments.value > 0 && selectedRows.value.size === totalDocuments.value,
    set: (val: boolean) => {
      selectedRows.value = val ? new Set(documents.value.map((doc) => doc._id.$oid)) : new Set()
    },
  })

  // --- Actions ---

  // Helper to get schema info
  const getSchemaInfo = (field: string) => {
    return collectionSchema.value.properties?.[field] || {}
  }

  // Helper to check if field is reference
  const isReferenceField = (field: string): boolean => {
    return getSchemaInfo(field).description?.includes('REF:') || false
  }

  // Helper to get referenced collection name
  const getReferencedCollection = (field: string): string | null => {
    const desc = getSchemaInfo(field).description || ''
    const match = desc.match(/REF:(\w+)/)
    return match ? match[1] : null
  }

  // Fetch list of collections
  async function fetchCollections() {
    try {
      const response = await fetch(`${API_BASE}/collections`)
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
      const { success, data, error } = await response.json()
      if (success) {
        collectionsList.value = data
        // Optionally set collectionName if current is invalid or empty
        if (data.length > 0 && (!collectionName.value || !data.includes(collectionName.value))) {
          // await setCollection(data[0]); // Uncomment if you want to auto-select
        }
      } else {
        throw new Error(error || 'Failed to fetch collections')
      }
    } catch (err: any) {
      errorMessage.value = `Error fetching collections: ${err.message}`
    }
  }

  // Set the current collection and fetch its data
  async function setCollection(name: string) {
    if (collectionName.value === name && documents.value.length > 0) return // Avoid refetch if already set

    collectionName.value = name
    // Reset state for the new collection
    documents.value = []
    collectionSchema.value = {}
    currentPage.value = 1
    selectedRows.value = new Set()
    editingCell.value = null
    isAdding.value = false
    errorMessage.value = ''
    referenceOptions.value = {} // Clear old references

    await fetchSchema() // Fetch schema first

    // Initialize hidden columns from schema
    hiddenColumns.value = collectionSchema.value.ui?.hiddenColumns || []

    await fetchDocuments() // Then fetch documents
    await preloadReferenceOptions() // Preload references needed by the schema
  }

  const pinDocument = async (documentId: string) => {
    if (!collectionName.value) {
      return
    }

    try {
      const response = await documentService.pinDocument(collectionName.value, documentId)

      if (response.success) {
        // Find and replace the document with the updated version from the response
        const updatedDoc = response.data
        const index = documents.value.findIndex((doc) => doc._id.$oid === documentId)

        if (index !== -1) {
          documents.value[index] = updatedDoc
        } else {
          // If not found, add to documents array (might be a new pinned document)
          documents.value.push(updatedDoc)
        }

        // Force array update for Vue reactivity
        documents.value = [...documents.value]

        toast({ title: 'Pinned', description: 'Document pinned successfully' })
      } else {
        errorMessage.value = `Error pinning document: ${response.error}`
        toast({ title: 'Pin Error', description: errorMessage.value, variant: 'destructive' })
      }
    } catch (err: any) {
      errorMessage.value = `Error pinning document: ${err.message}`
      toast({ title: 'Pin Error', description: errorMessage.value, variant: 'destructive' })
    }
  }

  const unpinDocument = async (documentId: string) => {
    if (!collectionName.value) {
      return
    }

    try {
      const response = await documentService.unpinDocument(collectionName.value, documentId)

      if (response.success) {
        // Find and replace the document with the updated version from the response
        const updatedDoc = response.data
        const index = documents.value.findIndex((doc) => doc._id.$oid === documentId)

        if (index !== -1) {
          documents.value[index] = updatedDoc
        } else {
          // If not found, add to documents array (might be a new pinned document)
        }

        // Force array update for Vue reactivity
        documents.value = [...documents.value]

        toast({ title: 'Unpinned', description: 'Document unpinned successfully' })
      } else {
        errorMessage.value = `Error unpinning document: ${response.error}`
        toast({ title: 'Unpin Error', description: errorMessage.value, variant: 'destructive' })
      }
    } catch (err: any) {
      errorMessage.value = `Error unpinning document: ${err.message}`
      toast({ title: 'Unpin Error', description: errorMessage.value, variant: 'destructive' })
    }
  }

  // Fetch schema for the current collection
  async function fetchSchema() {
    if (previewMode.value) return // Skip in preview
    if (!collectionName.value) return

    isLoading.value = true // Indicate loading schema
    errorMessage.value = ''

    try {
      // Prefer API fetch if available, fallback to invoke if needed
      const response = await fetch(`${API_BASE}/collections/${collectionName.value}/schema`)
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
      const { success, data, error } = await response.json()

      if (success) {
        collectionSchema.value = data

        // Apply preview state if in preview mode
        if (previewMode.value) {
          const savedUI = sessionStorage.getItem(`previewState-${collectionName.value}`)
          if (savedUI) {
            collectionSchema.value.ui = {
              ...collectionSchema.value.ui,
              ...JSON.parse(savedUI),
            }
          }
        }

        initializeNewDocument() // Initialize based on new schema
      } else {
        throw new Error(error || 'Schema fetch failed')
      }
    } catch (err: any) {
      errorMessage.value = `Schema error: ${err.message}`
      collectionSchema.value = {} // Reset schema on error
    } finally {
      isLoading.value = false // Schema loading finished
    }
  }

  // Fetch documents for the current collection and view
  async function fetchDocuments() {
    if (previewMode.value) return
    if (!collectionName.value) return

    isLoading.value = true
    errorMessage.value = ''
    pendingDeleteId.value = null

    try {
      let filter = {}
      try {
        filter = JSON.parse(filterQuery.value)
      } catch (e: any) {
        throw new Error(`Invalid filter JSON: ${e.message}`)
      }

      let endpoint
      switch (currentView.value) {
        case 'archives':
          endpoint = `${API_BASE}/collections/${collectionName.value}/archives`
          break
        case 'recoveries':
          endpoint = `${API_BASE}/collections/${collectionName.value}/recoveries`
          break
        case 'empty-or-recovered':
          endpoint = `${API_BASE}/collections/${collectionName.value}/empty-or-recovered`
          break
        case 'all':
        default:
          endpoint = `${API_BASE}/collections/${collectionName.value}/documents`
          break
      }

      const params = new URLSearchParams()
      params.append('filter', JSON.stringify(filter))
      params.append('page', currentPage.value.toString())
      params.append('limit', pageSize.value.toString())

      const url = `${endpoint}?${params.toString()}`
      const response = await fetch(url)

      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)

      const { success, data: responseData, error } = await response.json()

      if (success) {
        // Append new documents or replace if first page
        if (currentPage.value === 1) {
          documents.value = responseData.items
        } else {
          documents.value.push(...responseData.items)
        }

        totalDocuments.value = responseData.total
        hasMore.value = currentPage.value * pageSize.value < responseData.total

        // Reset page if no results
        if (currentPage.value > 1 && responseData.items.length === 0) {
          currentPage.value--
        }
      } else {
        throw new Error(error || 'Failed to fetch documents')
      }
    } catch (err: any) {
      errorMessage.value = `Error fetching documents: ${err.message}`
      if (currentPage.value > 1) currentPage.value--
    } finally {
      isLoading.value = false
    }
  }

  // --- New function to load next page ---
  async function loadNextPage() {
    if (!hasMore.value || isLoading.value) return
    currentPage.value++
    await fetchDocuments()
  }

  // --- Reset pagination when view changes ---
  function changeView(view: string) {
    if (currentView.value !== view) {
      currentView.value = view
      currentPage.value = 1
      documents.value = []
      hasMore.value = true
      fetchDocuments()
    }
  }

  // Preload reference options needed for the current schema
  async function preloadReferenceOptions() {
    if (!collectionSchema.value.properties) return

    const fields = Object.keys(collectionSchema.value.properties)
    for (const field of fields) {
      const refCollection = getReferencedCollection(field)
      if (refCollection && !referenceOptions.value[refCollection]) {
        await fetchReferenceOptions(refCollection)
      }
    }
  }

  // Fetch options for a referenced collection
  async function fetchReferenceOptions(refCollectionName: string, force = false) {
    if (!force && referenceOptions.value[refCollectionName]?.length > 0) {
      return // Already fetched or has data
    }
    if (loadingReferences.value[refCollectionName]) return // Already loading

    loadingReferences.value[refCollectionName] = true

    try {
      // 1. Fetch Schema to determine the best label field
      const schemaResponse = await fetch(`${API_BASE}/collections/${refCollectionName}/schema`)
      if (!schemaResponse.ok) throw new Error(`Schema fetch failed for ${refCollectionName}`)
      const {
        success: schemaSuccess,
        data: schemaData,
        error: schemaError,
      } = await schemaResponse.json()
      if (!schemaSuccess)
        throw new Error(schemaError || `Failed to fetch schema for ${refCollectionName}`)

      let labelField = '_id' // Default label
      const properties = schemaData.properties || {}
      const uniqueStringFields = Object.keys(properties).filter(
        (field) => properties[field].bsonType === 'string' && properties[field].unique === true
      )
      if (uniqueStringFields.length > 0) {
        labelField = uniqueStringFields[0] // Prefer unique string fields
      } else {
        const commonLabels = ['label', 'name', 'title', 'username']
        labelField = commonLabels.find((f) => properties[f]?.bsonType === 'string') || '_id'
      }

      // 2. Fetch Documents to populate options
      const docsResponse = await fetch(
        `${API_BASE}/collections/${refCollectionName}/documents?limit=1000`
      ) // Fetch all or limit as needed
      if (!docsResponse.ok) throw new Error(`Document fetch failed for ${refCollectionName}`)
      const { success: docsSuccess, data: docsData, error: docsError } = await docsResponse.json()

      if (docsSuccess) {
        // Check if paginated structure exists
        const items = docsData.items || docsData

        referenceOptions.value[refCollectionName] = items.map((doc: any) => ({
          id: doc._id.$oid, // Assuming MongoDB ObjectId structure
          label: doc[labelField] || doc._id.$oid, // Use determined label or fallback to ID
        }))

        if (referenceOptions.value[refCollectionName].length === 0) {
          toast({
            title: 'No Reference Options',
            description: `No documents found in collection '${refCollectionName}'.`,
            variant: 'default',
          })
        }
      } else {
        throw new Error(docsError || `Failed to fetch documents for ${refCollectionName}`)
      }
    } catch (err: any) {
      toast({
        title: 'Reference Error',
        description: `Failed to load options for ${refCollectionName}: ${err.message}`,
        variant: 'destructive',
      })
      referenceOptions.value[refCollectionName] = [] // Ensure it's an empty array on error
    } finally {
      loadingReferences.value[refCollectionName] = false
    }
  }

  // Get label for a reference ID
  function getReferenceLabel(field: string, id: string): string {
    const refCollection = getReferencedCollection(field)
    if (!refCollection) return id // Not a reference field
    const options = referenceOptions.value[refCollection] || []
    const option = options.find((opt) => opt.id === id)
    return option ? option.label : id // Return label or ID if not found
  }

  // Initialize the new document structure based on schema
  function initializeNewDocument() {
    const doc: Record<string, any> = {}
    const required = collectionSchema.value.required || []
    const properties = collectionSchema.value.properties || {}

    // Initialize required fields first (excluding specific auto-fields)
    required.forEach((field: string) => {
      if (['_id', 'created_at', 'updated_at'].includes(field)) return
      const prop = properties[field]
      if (prop) {
        doc[field] = getDefaultValue(prop.bsonType)
      }
    })

    // Consider adding default values for non-required fields if desired
    // Object.keys(properties).forEach(field => {
    //   if (!doc.hasOwnProperty(field) && !['_id', 'created_at', 'updated_at'].includes(field)) {
    //      doc[field] = getDefaultValue(properties[field].bsonType);
    //   }
    // });

    newDocument.value = doc
  }

  // Get default value based on BSON type
  function getDefaultValue(bsonType: string | string[]) {
    const type = Array.isArray(bsonType) ? bsonType[0] : bsonType // Handle potential array of types
    switch (type) {
      case 'string':
        return ''
      case 'int':
      case 'long':
      case 'double':
      case 'decimal':
        return 0
      case 'bool':
        return false
      case 'date':
        return new Date().toISOString() // Store dates consistently, e.g., ISO string
      case 'objectId':
        return null // Or handle differently if needed
      case 'object':
        return {}
      case 'array':
        return []
      default:
        return null
    }
  }

  // Start adding a new document
  function startAdding() {
    initializeNewDocument() // Ensure clean slate based on current schema
    isAdding.value = true
    addingRowError.value = false // Reset error state
    errorColumn.value = null
    // Pre-fetch references needed for the add form
    preloadReferenceOptions()
  }

  // Cancel adding
  function cancelAdding() {
    isAdding.value = false
    newDocument.value = {} // Clear the form
    addingRowError.value = false
    errorColumn.value = null
  }

  // Save the new document
  async function saveNewDocument() {
    if (!collectionName.value) return
    isSaving.value = true // Use isSaving for feedback
    errorMessage.value = ''
    errorColumn.value = null
    addingRowError.value = false

    try {
      const response = await fetch(`${API_BASE}/collections/${collectionName.value}/documents`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newDocument.value),
      })

      // Check if response is OK, even if not strictly JSON (e.g., 201 Created with no body)
      if (!response.ok) {
        // Try to parse error JSON, otherwise use status text
        let errorData
        try {
          errorData = await response.json()
        } catch (jsonError) {
          // Ignore json parse error if body is not json
        }
        const errorDetail = errorData?.error || `HTTP ${response.status}: ${response.statusText}`
        throw new Error(errorDetail)
      }

      // Handle potential non-JSON success response (like 201)
      let result
      const contentType = response.headers.get('content-type')
      if (contentType && contentType.includes('application/json')) {
        result = await response.json()
      } else {
        // Assume success if response.ok was true and no JSON body
        result = { success: true }
      }

      // Check application-level success (if applicable)
      if (result.success) {
        toast({ title: 'Success', description: 'Document created successfully.' })
        isAdding.value = false
        await fetchDocuments() // Refresh list
      } else {
        // This else block might be redundant if !response.ok is handled above,
        // but keep it if your API returns 200 OK with a success: false payload
        throw new Error(result.error || 'Failed to create document (API indicated failure)')
      }
    } catch (err: any) {
      errorMessage.value = err.message || 'Failed to create document'
      addingRowError.value = true // Indicate error on the add row

      // Handle specific errors like duplicates
      if (err.message && err.message.includes('E11000')) {
        // Extract field name from duplicate key error message
        const fieldMatch = err.message.match(/index: (\w+)_/) // Basic pattern, adjust if needed
        const valueMatch = err.message.match(/dup key: { (\w+): "(.+?)" }/) // More specific pattern
        const fieldName = valueMatch ? valueMatch[1] : fieldMatch ? fieldMatch[1] : null

        if (fieldName) {
          errorMessage.value = `Duplicate value detected for field "${fieldName}". Please use a unique value.`
          errorColumn.value = fieldName // Highlight the column in the add row
        } else {
          errorMessage.value = 'Duplicate value detected. Please check unique fields.'
        }
      }

      // Optionally use toast for errors too
      toast({ title: 'Save Error', description: errorMessage.value, variant: 'destructive' })
    } finally {
      isSaving.value = false
    }
  }

  // Start editing a cell
  function startEditingCell(rowIndex: number, header: string, currentValue: any) {
    if (isSaving.value) return // Don't allow edit while saving
    if (['_id', 'created_at', 'updated_at'].includes(header)) return // Non-editable fields

    // Commit previous edit if any
    if (editingCell.value) {
      // Consider auto-saving on blur/new cell click, or require explicit save
      // For simplicity here, we just cancel the previous edit visually
      // await saveEdit(); // Uncomment if you want to auto-save previous cell
    }

    const doc = paginatedDocuments.value[rowIndex]
    if (!doc) return

    editingCell.value = { rowIndex, header }

    // Format value for editing input
    const schemaInfo = getSchemaInfo(header)
    const bsonType = Array.isArray(schemaInfo.bsonType)
      ? schemaInfo.bsonType[0]
      : schemaInfo.bsonType

    if (bsonType === 'bool') {
      editValue.value = !!currentValue // Ensure boolean
    } else if (bsonType === 'date') {
      // Ensure date is in YYYY-MM-DDTHH:mm format for datetime-local input
      editValue.value = currentValue ? new Date(currentValue).toISOString().slice(0, 16) : ''
    } else if (isReferenceField(header)) {
      editValue.value = currentValue || '' // Store the ID for the select
      // Ensure options are loaded for the reference field
      const refCollection = getReferencedCollection(header)
      if (refCollection) {
        fetchReferenceOptions(refCollection)
      }
    } else if (typeof currentValue === 'object' && currentValue !== null) {
      editValue.value = JSON.stringify(currentValue, null, 2) // Pretty print objects/arrays
    } else {
      editValue.value = String(currentValue ?? '') // Handle null/undefined
    }
  }

  // Cancel editing a cell
  function cancelEdit() {
    editingCell.value = null
    editValue.value = ''
  }

  function updateDocument(docId: string, updatedDoc: any) {
    // Find document index in the main documents array
    const docIndex = documents.value.findIndex((doc) => doc._id.$oid === docId)

    if (docIndex !== -1) {
      // Replace the document with the updated version
      documents.value = documents.value.map((doc, index) => (index === docIndex ? updatedDoc : doc))

      // No need to update paginatedDocuments as it's a computed property
      // that will automatically update based on the documents array
    } else {
      // Document with ID not found in local state
    }
  }

  // Save an edited cell value
  async function saveEdit() {
    if (!editingCell.value || isSaving.value) return

    const { rowIndex, header } = editingCell.value
    const doc = paginatedDocuments.value[rowIndex]
    if (!doc) {
      cancelEdit()
      return
    }

    const docId = doc._id.$oid
    isSaving.value = true
    errorMessage.value = ''
    const originalValue = doc[header] // Store original value for comparison/revert

    try {
      let valueToSave: any
      const schemaInfo = getSchemaInfo(header)
      const bsonType = Array.isArray(schemaInfo.bsonType)
        ? schemaInfo.bsonType[0]
        : schemaInfo.bsonType

      // --- Parse/Validate editValue based on type ---
      if (isReferenceField(header)) {
        valueToSave = editValue.value // Assume editValue holds the selected ID string
      } else if (bsonType === 'bool') {
        valueToSave = Boolean(editValue.value)
      } else if (bsonType === 'date') {
        valueToSave = editValue.value ? new Date(editValue.value).toISOString() : null
      } else if (['int', 'long'].includes(bsonType)) {
        valueToSave = parseInt(editValue.value, 10)
        if (isNaN(valueToSave)) throw new Error('Invalid integer value')
      } else if (['double', 'decimal'].includes(bsonType)) {
        valueToSave = parseFloat(editValue.value)
        if (isNaN(valueToSave)) throw new Error('Invalid number value')
      } else if (bsonType === 'string') {
        valueToSave = editValue.value // Keep as string
      } else if (bsonType === 'object' || bsonType === 'array') {
        try {
          valueToSave = JSON.parse(editValue.value)
        } catch (e) {
          throw new Error('Invalid JSON format')
        }
      } else {
        valueToSave = editValue.value // Default case
      }

      // --- Check if value actually changed ---
      // Note: Deep comparison might be needed for objects/arrays if stringify isn't sufficient
      if (JSON.stringify(valueToSave) === JSON.stringify(originalValue)) {
        cancelEdit() // Exit edit mode
        return
      }

      const update = { [header]: valueToSave }
      const response = await fetch(
        `${API_BASE}/collections/${collectionName.value}/documents/${docId}`,
        {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(update),
        }
      )

      if (!response.ok) {
        let errorData
        try {
          errorData = await response.json()
        } catch {
          /* ignore */
        }
        throw new Error(errorData?.error || `Update failed: HTTP ${response.status}`)
      }

      const result = await response.json()

      if (result.success && result.data?.document) {
        const updatedDoc = result.data.document

        // Update the document in the store - this will automatically update any computed properties
        // using the proper store action instead of direct mutation
        updateDocument(docId, updatedDoc)

        toast({ title: 'Update Successful', description: `Field '${header}' updated.` })
        cancelEdit() // Exit edit mode on success
      } else if (result.success && result.data?.modified_count === 0) {
        // API succeeded but didn't modify (e.g., value was the same)
        cancelEdit()
      } else {
        throw new Error(result.error || 'Update failed (API indicated failure)')
      }
    } catch (err: any) {
      errorMessage.value = `Error updating field '${header}': ${err.message}`
      toast({ title: 'Update Error', description: errorMessage.value, variant: 'destructive' })
    } finally {
      isSaving.value = false
    }
  }

  // Delete a document
  async function deleteDocument(docId: string) {
    if (!collectionName.value) return
    pendingDeleteId.value = docId // Style the row during delete attempt
    errorMessage.value = ''

    try {
      const response = await fetch(
        `${API_BASE}/collections/${collectionName.value}/documents/${docId}`,
        { method: 'DELETE' }
      )

      if (!response.ok) {
        let errorData
        try {
          errorData = await response.json()
        } catch {
          /* ignore */
        }
        throw new Error(errorData?.error || `Delete failed: HTTP ${response.status}`)
      }

      // Check response body if API confirms success
      const result = await response.json() // Or handle non-JSON responses if applicable

      if (result.success) {
        // Adjust based on your API response structure
        toast({ title: 'Document Deleted', description: `Document ID: ${docId} deleted.` })
        // Remove from local state *after* successful deletion
        documents.value = documents.value.filter((doc) => doc._id.$oid !== docId)
        selectedRows.value.delete(docId) // Remove from selection if present
      } else {
        throw new Error(result.error || 'Delete failed (API indicated failure)')
      }
    } catch (err: any) {
      errorMessage.value = `Error deleting document ${docId}: ${err.message}`
      toast({ title: 'Delete Error', description: errorMessage.value, variant: 'destructive' })
    } finally {
      // Clear pending style regardless of success/failure *after* potential fetchDocuments
      // If fetchDocuments is called on success, it resets loading and pending ID
      if (errorMessage.value) {
        // Only clear if there was an error (success clears via fetch)
        pendingDeleteId.value = null
      }
      // Consider calling fetchDocuments() here instead of filtering locally
      // await fetchDocuments(); // This ensures consistency with the backend
    }
  }

  // Toggle row selection
  function toggleRow(id: string) {
    const newSet = new Set(selectedRows.value)
    if (newSet.has(id)) {
      newSet.delete(id)
    } else {
      newSet.add(id)
    }
    selectedRows.value = newSet // Assign new Set to trigger reactivity
    // Optional toast notification removed for brevity, add back if desired
  }

  // Reset selection
  function resetSelection() {
    selectedRows.value = new Set()
    editingCell.value = null // Also cancel any active edit
  }

  // Set current page
  function setPage(page: number) {
    const newPage = Math.max(1, Math.min(page, totalPages.value))
    if (currentPage.value !== newPage) {
      currentPage.value = newPage
      // Fetching might not be needed if pagination is purely client-side
      // If API supports server-side pagination, call fetchDocuments() here
    }
  }

  // Set page size
  function setPageSize(size: number) {
    pageSize.value = size
    currentPage.value = 1 // Reset to page 1 when size changes
    // Fetching might not be needed if pagination is purely client-side
    // If API supports server-side pagination, call fetchDocuments() here
  }

  async function updateDocumentField(documentId: string, field: string, value: any) {
    if (!collectionName.value) return

    errorMessage.value = ''

    try {
      const update = { [field]: value }
      const response = await fetch(
        `${API_BASE}/collections/${collectionName.value}/documents/${documentId}`,
        {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(update),
        }
      )

      if (!response.ok) {
        let errorData
        try {
          errorData = await response.json()
        } catch {
          /* ignore */
        }
        throw new Error(errorData?.error || `Update failed: HTTP ${response.status}`)
      }

      const result = await response.json()

      if (result.success) {
        // Update local document state
        const docIndex = documents.value.findIndex((d) => d._id.$oid === documentId)
        if (docIndex !== -1) {
          documents.value[docIndex] = { ...documents.value[docIndex], ...update }
          // Force reactivity update
          documents.value = [...documents.value]
        }
        return true
      } else {
        throw new Error(result.error || 'Update failed (API indicated failure)')
      }
    } catch (err: any) {
      errorMessage.value = `Error updating field '${field}': ${err.message}`
      toast({ title: 'Update Error', description: errorMessage.value, variant: 'destructive' })
      return false
    }
  }

  async function updateUIMetadata(uiUpdate: Record<string, any>) {
    if (!collectionName.value) return

    if (previewMode.value) {
      // Preview mode: save to sessionStorage
      const previewStateKey = `previewState-${collectionName.value}`
      const currentPreviewState = JSON.parse(sessionStorage.getItem(previewStateKey) || '{}')
      const updatedPreviewState = { ...currentPreviewState, ...uiUpdate }
      sessionStorage.setItem(previewStateKey, JSON.stringify(updatedPreviewState))

      // Update local schema without API call
      collectionSchema.value.ui = {
        ...collectionSchema.value.ui,
        ...uiUpdate,
      }
      return
    }

    // Regular mode: save to backend
    try {
      const response = await fetch(`${API_BASE}/collections/${collectionName.value}/ui-metadata`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(uiUpdate),
      })

      if (!response.ok) throw new Error('Failed to update UI metadata')
      await fetchSchema() // Refresh schema to get updated UI metadata
    } catch (error) {
      throw error
    }
  }

  const hiddenColumns = ref<string[]>([])

  // Add getter for visible headers
  const visibleHeaders = computed(() => {
    return tableHeaders.value.filter((header) => !hiddenColumns.value.includes(header))
  })

  // Add action to toggle visibility
  function toggleColumnVisibility(header: string) {
    const index = hiddenColumns.value.indexOf(header)
    if (index === -1) {
      hiddenColumns.value.push(header)
    } else {
      hiddenColumns.value.splice(index, 1)
    }

    if (previewMode.value) {
      savePreviewState()
    } else {
      saveColumnVisibilityToBackend()
    }
  }

  // Add action to save to backend
  async function saveColumnVisibilityToBackend() {
    if (!collectionName.value) return
    try {
      await updateUIMetadata({
        ...(collectionSchema.value.ui || {}), // Preserve existing UI metadata
        hiddenColumns: hiddenColumns.value, // Override hiddenColumns
      })
    } catch (error) {
      // Error handling without console.log
    }
  }

  // Update and save column widths
  async function updateColumnWidth(header: string, width: number) {
    if (!collectionSchema.value.ui) {
      collectionSchema.value.ui = {}
    }
    if (!collectionSchema.value.ui.columnWidths) {
      collectionSchema.value.ui.columnWidths = {}
    }
    // Update local schema immediately for responsiveness
    collectionSchema.value.ui.columnWidths = {
      ...collectionSchema.value.ui.columnWidths,
      [header]: Math.max(50, width), // Ensure minimum width
    }
    // Debounced save to backend will be handled in the component using this action
    await saveColumnWidthsToBackend()
  }

  // Reset a specific column width
  async function resetColumnWidth(header: string) {
    if (collectionSchema.value?.ui?.columnWidths?.[header]) {
      const newWidths = { ...collectionSchema.value.ui.columnWidths }
      delete newWidths[header]
      collectionSchema.value.ui.columnWidths = newWidths
      await saveColumnWidthsToBackend()
    }
  }

  const savePreviewState = useDebounceFn(() => {
    if (!collectionName.value) return

    // Save UI settings
    sessionStorage.setItem(
      `previewState-${collectionName.value}`,
      JSON.stringify(collectionSchema.value.ui)
    )

    // Save hidden columns
    sessionStorage.setItem(
      `previewHidden-${collectionName.value}`,
      JSON.stringify(hiddenColumns.value)
    )
  }, 500)

  // Save column widths to backend (called by debounced function in component)
  async function saveColumnWidthsToBackend() {
    if (!collectionName.value) return

    if (previewMode.value) {
      // Save to sessionStorage for Preview Mode
      const previewState = {
        ...collectionSchema.value.ui,
        columnWidths: columnWidths.value,
      }
      sessionStorage.setItem(`previewState-${collectionName.value}`, JSON.stringify(previewState))
    } else {
      try {
        const response = await fetch(
          `${API_BASE}/collections/${collectionName.value}/ui-metadata`,
          {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ columnWidths: columnWidths.value }),
          }
        )

        if (!response.ok) {
          let errorData
          try {
            errorData = await response.json()
          } catch {
            /* ignore */
          }
          throw new Error(errorData?.error || `Save widths failed: HTTP ${response.status}`)
        }

        const result = await response.json()
        if (!result.success) {
          throw new Error(result.error || 'Failed to save column widths (API Error)')
        }
      } catch (err: any) {
        toast({
          title: 'Save Error',
          description: `Could not save column widths: ${err.message}`,
          variant: 'destructive',
        })
      }
    }
  }

  // Clear error message
  function clearError() {
    errorMessage.value = ''
  }

  const shortNames = computed(() => {
    return collectionSchema.value?.ui?.short_names || {}
  })

  // Return state, getters, and actions
  return {
    // State
    hasMore,
    collectionName,
    documents,
    collectionSchema,
    isLoading,
    errorMessage,
    pageSize,
    currentPage,
    filterQuery, // Keep filter local to component or move here if needed globally
    newDocument,
    isAdding,
    editingCell,
    editValue,
    isSaving,
    selectedRows,
    currentView,
    pendingDeleteId,
    referenceOptions,
    loadingReferences,
    collectionsList,
    errorColumn,
    addingRowError,
    hiddenColumns,
    visibleHeaders,
    previewMode,

    // Getters
    totalDocuments,
    totalPages,
    paginatedDocuments,
    tableHeaders,
    columnWidths,
    allSelected,

    shortNames,
    // Actions
    fetchCollections,
    setCollection,
    fetchSchema, // Expose if needed externally, otherwise internal use
    fetchDocuments,
    fetchReferenceOptions,
    getReferenceLabel,
    initializeNewDocument, // Might be internal unless needed outside
    startAdding,
    cancelAdding,
    saveNewDocument,
    startEditingCell,
    cancelEdit,
    saveEdit,
    updateDocument,
    deleteDocument,
    toggleRow,
    resetSelection,
    changeView,
    loadNextPage,
    setPage,
    setPageSize,
    updateDocumentField,
    updateUIMetadata,
    toggleColumnVisibility,
    saveColumnVisibilityToBackend,
    updateColumnWidth,
    resetColumnWidth,
    saveColumnWidthsToBackend, // Exposed for debouncing in component
    clearError,
    getSchemaInfo, // Expose helpers if needed in component template
    isReferenceField,
    getReferencedCollection,
    pinDocument,
    unpinDocument,
  }
})
// src/utils/api.ts
import { AUTH_CONSTANTS } from '@/constants/auth'

// Helper function to get the API base URL
export function getApiBaseUrl(): string {
  const savedIp = localStorage.getItem('API_BASE_IP')
  return `http://${savedIp || 'localhost'}:3000`
}

// Get authentication headers
export function getAuthHeaders(): HeadersInit {
  const token = localStorage.getItem(AUTH_CONSTANTS.TOKEN_KEY)
  if (!token) {
    return {
      'Content-Type': 'application/json',
    }
  }

  return {
    'Content-Type': 'application/json',
    Authorization: `${AUTH_CONSTANTS.TOKEN_PREFIX} ${token}`,
  }
}

interface ApiResponse<T> {
  success: boolean
  data?: T
  error?: string
}

export async function apiFetch<T>(endpoint: string, options?: RequestInit): Promise<T> {
  const API_BASE = getApiBaseUrl()

  // Merge default headers with provided options
  const headers = {
    ...getAuthHeaders(),
    ...options?.headers,
  }

  const response = await fetch(`${API_BASE}${endpoint}`, {
    ...options,
    headers,
  })

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }

  const result: ApiResponse<T> = await response.json()

  if (!result.success) {
    throw new Error(result.error || 'Unknown API error')
  }

  return result.data as T
}

// Function to test the connection to the API server
export async function testConnection(timeout = 5000): Promise<boolean> {
  const API_BASE = getApiBaseUrl()

  try {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), timeout)

    const response = await fetch(`${API_BASE}/api/health`, {
      method: 'HEAD',
      signal: controller.signal,
    })

    clearTimeout(timeoutId)
    return response.ok
  } catch (error) {
    console.error('Connection test failed:', error)
    return false
  }
}

// src/utils/parseCSV.ts
import Papa from 'papaparse'

export interface ParseCSVResult {
  headers: string[]
  data: any[]
}

export const parseCSV = async (file: File): Promise<ParseCSVResult> => {
  return new Promise((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true,
      transform: (value: any, field: string) => {
        // Handle MongoDB-specific format conversions
        if (field.toLowerCase() === '_id') {
          return { $oid: value.toString() }
        }
        if (value instanceof Date) {
          return value.toISOString()
        }
        return value
      },
      complete: (results) => {
        if (results.errors.length) {
          return reject(new Error('CSV parsing errors: ' + JSON.stringify(results.errors)))
        }
        resolve({
          headers: results.meta.fields || [],
          data: results.data,
        })
      },
      error: (error: Error) => reject(error),
    })
  })
}
// src/api_server/handlers/csv_temp_handlers.rs

use axum::{extract::{Path, State}, http::StatusCode, Json};
use rusqlite::{Connection, params, types::Null};
use serde_json::{Value, Map};
use serde::Deserialize;
use std::{
    fs,
    path::PathBuf,
    sync::Arc,
};
use tokio::{sync::Mutex, task};
use crate::api_server::state::ApiServerState;
use std::env;
use anyhow::{Result as AnyhowResult, anyhow, Result};

// Structure for request parsing
#[derive(Debug, Deserialize)]
pub struct CsvUpload {
    valid: Vec<Value>,
    invalid: Vec<Value>,
}

// Helper function to get app data directory
fn get_app_data_dir() -> PathBuf {
    println!("DEBUG: Getting app data directory");
    let app_name = "vue-tauri";
    
    #[cfg(target_os = "windows")]
    {
        let app_data = env::var("APPDATA").unwrap_or_else(|_| {
            env::var("USERPROFILE").unwrap_or_else(|_| ".".to_string()) + "\\AppData\\Roaming"
        });
        let path = PathBuf::from(app_data).join(app_name);
        println!("DEBUG: Windows app data dir: {:?}", path);
        path
    }
    
    #[cfg(target_os = "macos")]
    {
        let home = env::var("HOME").unwrap_or_else(|_| ".".to_string());
        let path = PathBuf::from(home).join("Library").join("Application Support").join(app_name);
        println!("DEBUG: macOS app data dir: {:?}", path);
        path
    }
    
    #[cfg(target_os = "linux")]
    {
        let home = env::var("HOME").unwrap_or_else(|_| ".".to_string());
        let path = PathBuf::from(home).join(".local").join("share").join(app_name);
        println!("DEBUG: Linux app data dir: {:?}", path);
        path
    }
    
    #[cfg(not(any(target_os = "windows", target_os = "macos", target_os = "linux")))]
    {
        let path = PathBuf::from(".").join(app_name);
        println!("DEBUG: Default app data dir: {:?}", path);
        path
    }
}

// Get the database path for a collection
async fn get_db_path_from_state(state: &Arc<Mutex<ApiServerState>>, collection: &str) -> AnyhowResult<PathBuf> {
    println!("DEBUG: Getting DB path for collection: {}", collection);
    let state = state.lock().await;
    let temp_dirs = state.temp_dirs.lock().await;
    if let Some(path) = temp_dirs.get(collection) {
        println!("DEBUG: Found existing path in state: {:?}", path);
        Ok(path.clone())
    } else {
        println!("DEBUG: No path in state, creating new path");
        // Create a path in the app data directory if it doesn't exist
        let app_data_dir = task::spawn_blocking(get_app_data_dir)
            .await
            .map_err(|e| anyhow!("Failed to spawn blocking task: {}", e))?;
            
        let temp_dir = app_data_dir.join("temp").join(collection);
        println!("DEBUG: Created new temp dir: {:?}", temp_dir);
        
        let temp_dir_clone = temp_dir.clone();
        task::spawn_blocking(move || {
            println!("DEBUG: Creating directory: {:?}", temp_dir_clone);
            match fs::create_dir_all(&temp_dir_clone) {
                Ok(_) => {
                    println!("DEBUG: Directory created successfully");
                    Ok(())
                },
                Err(e) => {
                    println!("ERROR: Failed to create directory: {}", e);
                    Err(anyhow!("Failed to create temp directory: {}", e))
                }
            }
        })
        .await
        .map_err(|e| anyhow!("Task join error: {}", e))??;
        
        let db_path = temp_dir.join("temp_data.sqlite");
        println!("DEBUG: DB path: {:?}", db_path);
        Ok(db_path)
    }
}

// Add path to state
async fn add_path_to_state(state: &Arc<Mutex<ApiServerState>>, collection: String, path: PathBuf) -> AnyhowResult<()> {
    println!("DEBUG: Adding path to state for collection: {}", collection);
    let state = state.lock().await;
    let mut temp_dirs = state.temp_dirs.lock().await;
    temp_dirs.insert(collection, path);
    println!("DEBUG: Path added to state successfully");
    Ok(())
}

// Remove path from state
async fn remove_path_from_state(state: &Arc<Mutex<ApiServerState>>, collection: &str) -> AnyhowResult<Option<PathBuf>> {
    println!("DEBUG: Removing path from state for collection: {}", collection);
    let state = state.lock().await;
    let mut temp_dirs = state.temp_dirs.lock().await;
    let result = temp_dirs.remove(collection);
    
    if result.is_some() {
        println!("DEBUG: Path removed from state successfully");
    } else {
        println!("DEBUG: No path found to remove for collection: {}", collection);
    }
    
    Ok(result)
}

// Helper function to convert value to a rusqlite-compatible type
// Now returns Option<String> to properly represent NULL values
fn value_to_param(value: &Value) -> rusqlite::Result<Option<String>> {
    match value {
        Value::Null => {
            println!("DEBUG: Converting NULL value to None");
            Ok(None)
        },
        Value::Bool(b) => {
            println!("DEBUG: Converting Bool {} to String", b);
            Ok(Some(b.to_string()))
        },
        Value::Number(n) => {
            println!("DEBUG: Converting Number {} to String", n);
            Ok(Some(n.to_string()))
        },
        Value::String(s) => {
            // Treat empty strings as NULL
            if s.is_empty() {
                println!("DEBUG: Converting empty string to None");
                Ok(None)
            } else {
                println!("DEBUG: Keeping string value: {}", s);
                Ok(Some(s.clone()))
            }
        },
        Value::Array(_) | Value::Object(_) => {
            let str_val = value.to_string();
            println!("DEBUG: Converting complex value to string: {}", str_val);
            Ok(Some(str_val))
        },
    }
}

// Create table for valid data with _id TEXT as primary key
fn create_valid_table(conn: &Connection, data: &[Value]) -> Result<()> {
    println!("DEBUG: Creating valid_data table");
    
    match conn.execute("DROP TABLE IF EXISTS valid_data", []) {
        Ok(_) => println!("DEBUG: Successfully dropped existing valid_data table"),
        Err(e) => {
            let error_msg = format!("Failed to drop valid_data table: {}", e);
            println!("ERROR: {}", error_msg);
            return Err(anyhow!(error_msg));
        }
    }
    
    if let Some(first) = data.first() {
        match first {
            Value::Object(obj) => {
                // Get headers and exclude 'id' field (we'll use '_id' as primary key)
                let headers: Vec<String> = obj.keys()
                    .filter(|&k| k != "id" && k != "_id")
                    .map(|k| k.to_string())
                    .collect();
                
                println!("DEBUG: Extracted headers: {:?}", headers);
                
                // Build CREATE TABLE SQL with _id as primary key
                let mut create_sql = "CREATE TABLE valid_data (\"_id\" TEXT PRIMARY KEY".to_string();
                for header in &headers {
                    // Escape column names to handle special characters
                    let column_def = format!(", \"{}\" TEXT", header.replace("\"", "\"\""));
                    create_sql.push_str(&column_def);
                }
                create_sql.push_str(")");
                
                println!("DEBUG: Valid table SQL: {}", create_sql);
                
                match conn.execute(&create_sql, []) {
                    Ok(_) => {
                        println!("DEBUG: Successfully created valid_data table");
                        Ok(())
                    },
                    Err(e) => {
                        let error_msg = format!("Failed to create valid_data table: {}", e);
                        println!("ERROR: {}", error_msg);
                        Err(anyhow!(error_msg))
                    }
                }
            },
            _ => {
                let error_msg = "First data item is not an object";
                println!("ERROR: {}", error_msg);
                Err(anyhow!(error_msg))
            }
        }
    } else {
        // Create empty table with just _id if no data
        println!("DEBUG: Creating empty valid_data table with just _id column");
        match conn.execute("CREATE TABLE valid_data (\"_id\" TEXT PRIMARY KEY)", []) {
            Ok(_) => {
                println!("DEBUG: Successfully created empty valid_data table");
                Ok(())
            },
            Err(e) => {
                let error_msg = format!("Failed to create empty valid_data table: {}", e);
                println!("ERROR: {}", error_msg);
                Err(anyhow!(error_msg))
            }
        }
    }
}

// Modified: Create table for invalid data with the same schema as valid_data plus errors column
fn create_invalid_table(conn: &Connection, valid_columns: &[String]) -> Result<()> {
    println!("DEBUG: Starting to create invalid_data table");
    println!("DEBUG: Valid columns received: {:?}", valid_columns);
    
    // First drop the table if it exists
    match conn.execute("DROP TABLE IF EXISTS invalid_data", []) {
        Ok(_) => println!("DEBUG: Successfully dropped existing invalid_data table"),
        Err(e) => {
            let error_msg = format!("Failed to drop invalid_data table: {}", e);
            println!("ERROR: {}", error_msg);
            return Err(anyhow!(error_msg));
        }
    }
    
    // Build the CREATE TABLE SQL statement
    let mut create_sql = "CREATE TABLE invalid_data (\"_id\" TEXT PRIMARY KEY".to_string();
    
    // Add all columns from valid table as TEXT
    for column in valid_columns {
        if column != "_id" {
            let column_def = format!(", \"{}\" TEXT", column.replace("\"", "\"\""));
            create_sql.push_str(&column_def);
            println!("DEBUG: Added column definition: {}", column_def);
        }
    }
    
    // Add errors column
    create_sql.push_str(", errors TEXT)");
    
    println!("DEBUG: Final CREATE TABLE SQL: {}", create_sql);
    
    // Execute the CREATE TABLE statement
    match conn.execute(&create_sql, []) {
        Ok(_) => {
            println!("DEBUG: Successfully created invalid_data table");
            Ok(())
        },
        Err(e) => {
            let error_msg = format!("Failed to create invalid_data table: {}", e);
            println!("ERROR: {}", error_msg);
            Err(anyhow!(error_msg))
        }
    }
}

// Insert valid data with _id as primary key
fn insert_valid_data(conn: &Connection, data: &[Value]) -> Result<()> {
    println!("DEBUG: Inserting valid data, {} rows", data.len());
    
    if data.is_empty() {
        println!("DEBUG: No valid data to insert");
        return Ok(());
    }
    
    let first_item = match &data[0] {
        Value::Object(obj) => {
            println!("DEBUG: First item is an object with {} keys", obj.len());
            obj
        },
        _ => {
            let error_msg = "Data items must be objects";
            println!("ERROR: {}", error_msg);
            return Err(anyhow!(error_msg));
        }
    };
    
    // Get headers excluding 'id' field
    let headers: Vec<String> = first_item.keys()
        .filter(|&k| k != "id" && k != "_id")
        .map(|k| k.to_string())
        .collect();
    
    println!("DEBUG: Headers for valid data: {:?}", headers);
    
    // Build placeholders for prepared statement (including _id placeholder)
    let placeholders: Vec<String> = (0..headers.len() + 1)
        .map(|_| "?".to_string())
        .collect();
        
    // Build columns for INSERT statement (including _id column)
    let columns = format!("\"_id\", {}", headers.iter()
        .map(|h| format!("\"{}\"", h.replace("\"", "\"\"")))
        .collect::<Vec<_>>()
        .join(", "));
        
    // Create INSERT SQL statement
    let insert_sql = format!(
        "INSERT INTO valid_data ({}) VALUES ({})",
        columns,
        placeholders.join(", ")
    );
    
    println!("DEBUG: Valid data INSERT SQL: {}", insert_sql);

    // Prepare statement once for multiple executions
    let mut stmt = match conn.prepare(&insert_sql) {
        Ok(stmt) => {
            println!("DEBUG: Successfully prepared statement for valid data");
            stmt
        },
        Err(e) => {
            let error_msg = format!("Failed to prepare statement: {}", e);
            println!("ERROR: {}", error_msg);
            return Err(anyhow!(error_msg));
        }
    };

    // Insert each row
    let mut row_count = 0;
    for item in data {
        row_count += 1;
        println!("DEBUG: Processing valid data row {}", row_count);
        
        let obj = match item {
            Value::Object(obj) => obj,
            _ => {
                println!("DEBUG: Skipping non-object item");
                continue; // Skip non-object items
            }
        };
        
        // Extract _id from item, generate one if not present
        let mongo_id = match obj.get("_id") {
            Some(Value::String(id)) if !id.is_empty() => {
                println!("DEBUG: Using existing _id: {}", id);
                id.clone()
            },
            _ => match obj.get("id") {
                Some(Value::String(id)) if !id.is_empty() => {
                    println!("DEBUG: Using id as _id: {}", id);
                    id.clone()
                },
                Some(Value::Number(n)) => {
                    println!("DEBUG: Using number id as _id: {}", n);
                    n.to_string()
                },
                _ => {
                    let uuid = uuid::Uuid::new_v4().to_string();
                    println!("DEBUG: Generated UUID as _id: {}", uuid);
                    uuid // Generate a UUID if no _id or id exists
                }
            }
        };
        
        // Extract values in the same order as headers
        let mut values: Vec<Option<String>> = vec![Some(mongo_id)]; // Start with _id
        println!("DEBUG: Extracting values for {} headers", headers.len());
        
        for h in &headers {
            println!("DEBUG: Processing header: {}", h);
            let value = match obj.get(h) {
                Some(val) => {
                    match value_to_param(val) {
                        Ok(v) => {
                            println!("DEBUG: Got value for {}: {:?}", h, v);
                            v
                        },
                        Err(e) => {
                            println!("ERROR: Failed to convert value for {}: {}", h, e);
                            None
                        }
                    }
                },
                None => {
                    println!("DEBUG: No value for {}, using NULL", h);
                    None // Missing field becomes NULL
                }
            };
            values.push(value);
        }
            
        // Convert values to params for the prepared statement
        println!("DEBUG: Converting {} values to params", values.len());
        let params_slice: Vec<&dyn rusqlite::ToSql> = values
            .iter()
            .map(|v| match v {
                Some(s) => {
                    println!("DEBUG: String param: {}", s);
                    s as &dyn rusqlite::ToSql
                },
                None => {
                    println!("DEBUG: NULL param");
                    &Null as &dyn rusqlite::ToSql // Use rusqlite::types::Null for NULL values
                },
            })
            .collect();
            
        println!("DEBUG: Executing INSERT with {} params", params_slice.len());
        match stmt.execute(params_slice.as_slice()) {
            Ok(_) => println!("DEBUG: Successfully inserted valid data row {}", row_count),
            Err(e) => {
                let error_msg = format!("Failed to insert data row {}: {}", row_count, e);
                println!("ERROR: {}", error_msg);
                return Err(anyhow!(error_msg));
            }
        }
    }

    println!("DEBUG: Successfully inserted all valid data ({} rows)", row_count);
    Ok(())
}

// Modified: Insert invalid data with the same structure as valid_data plus errors column
fn insert_invalid_data(conn: &Connection, data: &[Value], valid_columns: &[String]) -> Result<()> {
    println!("DEBUG: Inserting invalid data, {} rows", data.len());
    println!("DEBUG: Valid columns for reference: {:?}", valid_columns);
    
    if data.is_empty() {
        println!("DEBUG: No invalid data to insert");
        return Ok(());
    }
    
    // Build columns list
    let mut columns = Vec::new();
    columns.push("\"_id\"".to_string());
    
    for column in valid_columns {
        if column != "_id" {
            columns.push(format!("\"{}\"", column.replace("\"", "\"\"")));
        }
    }
    
    columns.push("errors".to_string());
    println!("DEBUG: Invalid data columns: {:?}", columns);
    
    // Build placeholders
    let placeholders: Vec<String> = (0..columns.len())
        .map(|_| "?".to_string())
        .collect();
    println!("DEBUG: Generated {} placeholders", placeholders.len());
    
    // Build INSERT statement    
    let insert_sql = format!(
        "INSERT INTO invalid_data ({}) VALUES ({})",
        columns.join(", "),
        placeholders.join(", ")
    );
    println!("DEBUG: Invalid data INSERT SQL: {}", insert_sql);

    let mut stmt = match conn.prepare(&insert_sql) {
        Ok(stmt) => {
            println!("DEBUG: Successfully prepared statement for invalid data");
            stmt
        },
        Err(e) => {
            let error_msg = format!("Failed to prepare invalid data statement: {}", e);
            println!("ERROR: {}", error_msg);
            return Err(anyhow!(error_msg));
        }
    };

    let mut row_count = 0;
    for item in data {
        row_count += 1;
        println!("DEBUG: Processing invalid data row {}", row_count);
        
        let obj = match item {
            Value::Object(obj) => {
                println!("DEBUG: Found object with {} keys", obj.len());
                obj
            },
            _ => {
                println!("DEBUG: Skipping non-object item");
                continue; // Skip non-object items
            }
        };
        
        // Extract or generate _id
        let mongo_id = match obj.get("_id") {
            Some(Value::String(id)) if !id.is_empty() => {
                println!("DEBUG: Using existing _id: {}", id);
                id.clone()
            },
            _ => match obj.get("id") {
                Some(Value::String(id)) if !id.is_empty() => {
                    println!("DEBUG: Using id as _id: {}", id);
                    id.clone()
                },
                Some(Value::Number(n)) => {
                    println!("DEBUG: Using number id as _id: {}", n);
                    n.to_string()
                },
                _ => {
                    let uuid = uuid::Uuid::new_v4().to_string();
                    println!("DEBUG: Generated UUID as _id: {}", uuid);
                    uuid // Generate a UUID if no _id or id exists
                }
            }
        };
        
        // Extract values for each column
        let mut values: Vec<Option<String>> = vec![Some(mongo_id)]; // Start with _id
        println!("DEBUG: Extracting values for {} columns", valid_columns.len() - 1);
        
        for column in valid_columns {
            if column != "_id" {
                println!("DEBUG: Processing column: {}", column);
                // Try to get value from row data
                let value = if let Some(row) = obj.get("row") {
                    match row {
                        Value::Object(row_obj) => {
                            println!("DEBUG: Found row object with {} keys", row_obj.len());
                            if let Some(val) = row_obj.get(column) {
                                println!("DEBUG: Found value in row object for {}", column);
                                match value_to_param(val) {
                                    Ok(v) => {
                                        println!("DEBUG: Converted value for {}: {:?}", column, v);
                                        v
                                    },
                                    Err(e) => {
                                        println!("ERROR: Failed to convert value for {}: {}", column, e);
                                        None
                                    }
                                }
                            } else {
                                println!("DEBUG: No value in row object for {}, using NULL", column);
                                None
                            }
                        },
                        _ => {
                            println!("DEBUG: Row is not an object, using NULL for {}", column);
                            None
                        }
                    }
                } else {
                    // Try to get directly from the object
                    println!("DEBUG: No 'row' property, checking direct property for {}", column);
                    match obj.get(column) {
                        Some(val) => {
                            println!("DEBUG: Found direct property for {}", column);
                            match value_to_param(val) {
                                Ok(v) => {
                                    println!("DEBUG: Converted value for {}: {:?}", column, v);
                                    v
                                },
                                Err(e) => {
                                    println!("ERROR: Failed to convert value for {}: {}", column, e);
                                    None
                                }
                            }
                        },
                        None => {
                            println!("DEBUG: No direct property for {}, using NULL", column);
                            None
                        }
                    }
                };
                values.push(value);
            }
        }
        
        // Add errors 
        let errors = match obj.get("errors") {
            Some(v) => {
                let errors_str = v.to_string();
                println!("DEBUG: Found errors: {}", errors_str);
                errors_str
            },
            None => {
                println!("DEBUG: No errors found, using empty array");
                "[]".to_string()
            }
        };
        values.push(Some(errors));
        
        // Convert values to params for the prepared statement
        println!("DEBUG: Converting {} values to params", values.len());
        let params_slice: Vec<&dyn rusqlite::ToSql> = values
            .iter()
            .map(|v| match v {
                Some(s) => {
                    println!("DEBUG: String param: {}", s);
                    s as &dyn rusqlite::ToSql
                },
                None => {
                    println!("DEBUG: NULL param");
                    &Null as &dyn rusqlite::ToSql
                },
            })
            .collect();
            
        println!("DEBUG: Executing INSERT with {} params", params_slice.len());
        match stmt.execute(params_slice.as_slice()) {
            Ok(_) => println!("DEBUG: Successfully inserted invalid data row {}", row_count),
            Err(e) => {
                let error_msg = format!("Failed to insert invalid data row {}: {}", row_count, e);
                println!("ERROR: {}", error_msg);
                return Err(anyhow!(error_msg));
            }
        }
    }
    
    println!("DEBUG: Successfully inserted all invalid data ({} rows)", row_count);
    Ok(())
}

pub async fn save_csv_temp(
    State(state): State<Arc<Mutex<ApiServerState>>>,
    Path(collection): Path<String>,
    Json(data): Json<CsvUpload>,
) -> Result<(), (StatusCode, String)> {
    tracing::info!("Starting save_csv_temp for collection: {}", collection);
    
    if data.valid.is_empty() && data.invalid.is_empty() {
        tracing::warn!("No data provided for collection: {}", collection);
        return Err((StatusCode::BAD_REQUEST, "No data provided".to_string()));
    }

    tracing::debug!("Valid records: {}, Invalid records: {}", data.valid.len(), data.invalid.len());

    // Get app data directory in a non-blocking way
    tracing::debug!("Getting app data directory");
    let app_data_dir = task::spawn_blocking(get_app_data_dir)
        .await
        .map_err(|e| {
            tracing::error!("Failed to spawn blocking task for get_app_data_dir: {}", e);
            (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to spawn blocking task: {}", e))
        })?;
    
    let temp_dir = app_data_dir.join("temp").join(&collection);
    let db_path = temp_dir.join("temp_data.sqlite");
    
    tracing::debug!("Using temp directory: {:?}", temp_dir);
    tracing::debug!("Using database path: {:?}", db_path);
    
    // Create directories using blocking task
    let temp_dir_clone = temp_dir.clone();
    tracing::debug!("Creating directory structure");
    task::spawn_blocking(move || {
        fs::create_dir_all(&temp_dir_clone)
            .map_err(|e| anyhow!("Failed to create directory: {}", e))
    })
    .await
    .map_err(|e| {
        tracing::error!("Task join error when creating directories: {}", e);
        (StatusCode::INTERNAL_SERVER_ERROR, format!("Task join error: {}", e))
    })?
    .map_err(|e| {
        tracing::error!("Failed to create directories: {}", e);
        (StatusCode::INTERNAL_SERVER_ERROR, e.to_string())
    })?;
    
    // Store path in state
    tracing::debug!("Adding path to state for collection: {}", collection);
    add_path_to_state(&state, collection.clone(), db_path.clone())
        .await
        .map_err(|e| {
            tracing::error!("Failed to add path to state: {}", e);
            (StatusCode::INTERNAL_SERVER_ERROR, e.to_string())
        })?;

    // Clone data and path for move into blocking task
    let data_clone = data;
    let db_path_clone = db_path.clone();
    
    // Execute SQLite operations in blocking task
    tracing::debug!("Starting database operations in blocking task");
    task::spawn_blocking(move || -> AnyhowResult<()> {
        tracing::debug!("Opening database connection");
        let conn = Connection::open(&db_path_clone)
            .map_err(|e| {
                tracing::error!("Failed to open database: {}", e);
                anyhow!("Failed to open database: {}", e)
            })?;
        
        // Create valid data table
        tracing::debug!("Creating valid data table");
        create_valid_table(&conn, &data_clone.valid)?;
        
        // Get valid table columns
        tracing::debug!("Retrieving valid table columns");
        let mut stmt = conn.prepare("SELECT name FROM pragma_table_info('valid_data')")
            .map_err(|e| {
                tracing::error!("Failed to prepare column query: {}", e);
                anyhow!("Failed to prepare column query: {}", e)
            })?;
        
        let valid_columns: Vec<String> = stmt.query_map([], |row| {
            let column_name: String = row.get(0)?;
            Ok(column_name)
        })
        .map_err(|e| {
            tracing::error!("Failed to query columns: {}", e);
            anyhow!("Failed to query columns: {}", e)
        })?
        .collect::<Result<Vec<String>, _>>()
        .map_err(|e| {
            tracing::error!("Column error: {}", e);
            anyhow!("Column error: {}", e)
        })?;
        
        tracing::debug!("Found {} columns in valid table", valid_columns.len());
        
        // Create invalid table with same schema plus errors
        tracing::debug!("Creating invalid data table");
        create_invalid_table(&conn, &valid_columns)?;
        
        // Insert valid data
        tracing::debug!("Inserting {} valid records", data_clone.valid.len());
        insert_valid_data(&conn, &data_clone.valid)?;
        
        // Insert invalid data
        tracing::debug!("Inserting {} invalid records", data_clone.invalid.len());
        insert_invalid_data(&conn, &data_clone.invalid, &valid_columns)?;

        tracing::info!("Successfully completed database operations for collection: {}", &db_path_clone.display());
        Ok(())
    })
    .await
    .map_err(|e| {
        tracing::error!("Task join error during database operations: {}", e);
        (StatusCode::INTERNAL_SERVER_ERROR, format!("Task join error: {}", e))
    })?
    .map_err(|e| {
        tracing::error!("Database operation error: {}", e);
        (StatusCode::INTERNAL_SERVER_ERROR, e.to_string())
    })?;

    tracing::info!("Successfully saved CSV data to temp storage for collection: {}", collection);
    Ok(())
}

// Load CSV temp with improved _id handling in result processing
pub async fn load_csv_temp(
    State(state): State<Arc<Mutex<ApiServerState>>>,
    Path(collection): Path<String>,
) -> Result<Json<Value>, (StatusCode, String)> {
    // Get the database path from state
    let db_path = get_db_path_from_state(&state, &collection)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    
    // Check if the database file exists
    let db_path_clone = db_path.clone();
    let file_exists = task::spawn_blocking(move || db_path_clone.exists())
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Task join error: {}", e)))?;
    
    if !file_exists {
        return Err((StatusCode::NOT_FOUND, format!("No temporary data found for collection: {}", collection)));
    }
    
    // Execute SQLite operations in blocking task
    let results = task::spawn_blocking(move || -> AnyhowResult<Value> {
        let conn = Connection::open(&db_path)
            .map_err(|e| anyhow!("Failed to open database: {}", e))?;
        
        // Load valid data
        let valid_data = load_table_data(&conn, "valid_data")?;
        
        // Load invalid data
        let invalid_data = load_table_data(&conn, "invalid_data")?;
        
        // Create response with both sets of data
        let mut response = Map::new();
        response.insert("valid".to_string(), Value::Array(valid_data));
        response.insert("invalid".to_string(), Value::Array(invalid_data));
        
        Ok(Value::Object(response))
    })
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Task join error: {}", e)))?
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    Ok(Json(results))
}

// Helper function with proper _id handling
fn load_table_data(conn: &Connection, table_name: &str) -> Result<Vec<Value>> {
    // First check if table exists
    let table_exists = conn.query_row(
        "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
        params![table_name],
        |_| Ok(true)
    ).unwrap_or(false);
    
    if !table_exists {
        return Ok(Vec::new());
    }
    
    // Get the column names
    let mut stmt = conn.prepare(&format!("PRAGMA table_info({})", table_name))
        .map_err(|e| anyhow!("Failed to get table info: {}", e))?;
        
    let columns: Vec<String> = stmt.query_map([], |row| {
        let column_name: String = row.get(1)?;
        Ok(column_name)
    })
    .map_err(|e| anyhow!("Failed to query columns: {}", e))?
    .collect::<Result<Vec<String>, _>>()
    .map_err(|e| anyhow!("Column error: {}", e))?;
    
    // Prepare and execute SELECT statement for all rows
    let mut stmt = conn.prepare(&format!("SELECT * FROM {}", table_name))
        .map_err(|e| anyhow!("Failed to prepare statement: {}", e))?;
        
    let rows = stmt.query_map([], |row| {
        let mut obj = Map::new();
        
        // Process each column
        for (i, column_name) in columns.iter().enumerate() {
            // Check if column value is NULL
            let val: Option<String> = row.get(i)?;
            
            if let Some(s) = val {
                // Special handling for errors column in invalid_data table
                if table_name == "invalid_data" && column_name == "errors" {
                    // Try to parse errors as JSON
                    if let Ok(json_val) = serde_json::from_str::<Value>(&s) {
                        obj.insert(column_name.clone(), json_val);
                        continue;
                    }
                }
                
                // Try to parse as JSON if it looks like JSON
                let json_val = if (s.starts_with('{') && s.ends_with('}')) || 
                   (s.starts_with('[') && s.ends_with(']')) ||
                   (s == "true" || s == "false" || s == "null") ||
                   s.parse::<f64>().is_ok() {
                    serde_json::from_str(&s).unwrap_or(Value::String(s))
                } else {
                    Value::String(s)
                };
                
                obj.insert(column_name.clone(), json_val);
            } else {
                // Insert explicit null for NULL values from DB
                obj.insert(column_name.clone(), Value::Null);
            }
        }
        
        // Include _id as id for backward compatibility
        if let Some(mongo_id) = obj.get("_id").cloned() {
            obj.insert("id".to_string(), mongo_id.clone());
        }
        
        Ok(Value::Object(obj))
    })
    .map_err(|e| anyhow!("Query failed: {}", e))?;

    let mut results = Vec::new();
    for row in rows {
        results.push(row.map_err(|e| anyhow!("Row error: {}", e))?);
    }

    Ok(results)
}

pub async fn delete_csv_temp(
    State(state): State<Arc<Mutex<ApiServerState>>>,
    Path(collection): Path<String>,
) -> Result<(), (StatusCode, String)> {
    // Get app data directory to find the collection directory
    let app_data_dir = task::spawn_blocking(get_app_data_dir)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to spawn blocking task: {}", e)))?;
    
    // The collection directory is in "temp/{collection}"
    let collection_dir = app_data_dir.join("temp").join(&collection);
    
    // Remove path from state
    let _ = remove_path_from_state(&state, &collection)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    
    // Check if directory exists and remove it recursively
    let collection_dir_clone = collection_dir.clone();
    let dir_exists = task::spawn_blocking(move || collection_dir_clone.exists())
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Task join error: {}", e)))?;
    
    if dir_exists {
        // Remove the entire directory recursively
        task::spawn_blocking(move || fs::remove_dir_all(&collection_dir))
            .await
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Task join error: {}", e)))?
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to remove directory: {}", e)))?;
    }
    
    Ok(())
}
// src/api_server/routes.rs

use axum::{
    routing::{get, post, put, delete},
    http::Method,
    Router,
};
use std::sync::Arc;
use tokio::sync::Mutex;
use tower_http::cors::{Any, CorsLayer};
use crate::api_server::{
    state::ApiServerState,
    handlers::{
        auth_handlers::{
            auth_login_handler,
            auth_get_me_handler,
            auth_register_handler,
            auth_check_session_handler,
        },
        collection_handlers::{
            list_collections_handler,
            get_collection_schema_handler,
            update_ui_metadata_handler,
        },
        document_handlers::{
            find_documents_handler,
            find_empty_or_recovered_documents_handler,
            find_empty_archive_history_handler,
            find_archived_documents_handler,
            find_recovered_documents_handler,
            find_pinned_documents_handler,
            insert_document_handler,
            update_document_handler,
            delete_document_handler,
            batch_delete_documents_handler,
            archive_document_handler,
            batch_archive_documents_handler,
            recover_document_handler,
            batch_recover_documents_handler,
            pin_document_handler,
            unpin_document_handler,
            download_collection_csv_handler,

        },
        system_handlers::{
            health_check_handler,
            initialize_library_collections_handler,
        },
        csv_temp_handlers::{
            load_csv_temp,
            save_csv_temp,
            delete_csv_temp
        }
    },
};

// Create the API router and return both the router and a list of routes
pub fn create_api_router() -> (Router<Arc<Mutex<ApiServerState>>>, Vec<String>) {
    let mut routes = Vec::new();
    let mut router = Router::new();
    
    // Setup CORS
    let cors = CorsLayer::new()
        .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE, Method::OPTIONS])
        .allow_headers(Any)
        .allow_origin(Any);
    
    // Macro to add routes and track them
    macro_rules! add_route {
        ($method:expr, $path:expr, $handler:expr) => {
            router = match $method {
                Method::GET => router.route($path, get($handler)),
                Method::POST => router.route($path, post($handler)),
                Method::PUT => router.route($path, put($handler)),
                Method::DELETE => router.route($path, delete($handler)),
                _ => panic!("Unsupported method: {}. Update the router implementation.", $method),
            };
            routes.push(format!("{} {}", $method, $path));
        };
    }
    
    // Collection routes
    add_route!(Method::GET, "/collections", list_collections_handler);
    add_route!(Method::GET, "/collections/:collection_name/schema", get_collection_schema_handler);
    add_route!(Method::PUT, "/collections/:collection_name/ui-metadata", update_ui_metadata_handler);
    
    // route for temp sqlite3 csv temporary storage
    add_route!(Method::POST, "/api/csv-temp/:collection", save_csv_temp);
    add_route!(Method::GET, "/api/csv-temp/:collection", load_csv_temp);
    add_route!(Method::DELETE, "/api/csv-temp/:collection", delete_csv_temp);

    // Document routes
    add_route!(Method::GET, "/collections/:collection_name/documents", find_documents_handler);
    add_route!(
        Method::GET, 
        "/collections/:collection_name/empty-or-recovered", 
        find_empty_or_recovered_documents_handler
    );
    add_route!(
        Method::GET, 
        "/collections/:collection_name/empty-archive-history", 
        find_empty_archive_history_handler
    );
    add_route!(Method::GET, "/collections/:collection_name/archives", find_archived_documents_handler);
    add_route!(Method::GET, "/collections/:collection_name/recoveries", find_recovered_documents_handler);
    add_route!(Method::GET, "/collections/:collection_name/pins", find_pinned_documents_handler);
    add_route!(Method::POST, "/collections/:collection_name/documents", insert_document_handler);
    add_route!(Method::PUT, "/collections/:collection_name/documents/:id", update_document_handler);
    add_route!(Method::DELETE, "/collections/:collection_name/documents/:id", delete_document_handler);
    add_route!(
        Method::POST, 
        "/collections/:collection_name/documents/batch-delete", 
        batch_delete_documents_handler
    );
    add_route!(Method::PUT, "/collections/:collection_name/documents/:id/archive", archive_document_handler);
    add_route!(
        Method::POST, 
        "/collections/:collection_name/documents/batch-archive", 
        batch_archive_documents_handler
    );
    add_route!(Method::PUT, "/collections/:collection_name/documents/:id/recover", recover_document_handler);
    add_route!(
        Method::POST, 
        "/collections/:collection_name/documents/batch-recover", 
        batch_recover_documents_handler
    );
    add_route!(Method::PUT, "/collections/:collection_name/documents/:id/pin", pin_document_handler);
    add_route!(Method::PUT, "/collections/:collection_name/documents/:id/unpin", unpin_document_handler);

    add_route!(Method::GET, "/collections/:collection_name/download-csv", download_collection_csv_handler);
    
    // Auth routes
    add_route!(Method::POST, "/api/auth/login", auth_login_handler);
    add_route!(Method::GET, "/api/auth/me", auth_get_me_handler);
    add_route!(Method::POST, "/api/auth/register", auth_register_handler);
    add_route!(Method::POST, "/api/auth/check-session", auth_check_session_handler);
    // System routes
    add_route!(Method::POST, "/api/initialize-library-collections", initialize_library_collections_handler);
    add_route!(Method::GET, "/api/health", health_check_handler);
    
    // Apply CORS middleware
    router = router.layer(cors);
    
    (router, routes)
}
// src/api_server/state.rs
use crate::mongodb_manager::MongoDbState;
use crate::session::SessionManager;
use std::sync::Arc;
use std::collections::HashMap;
use std::path::PathBuf;
use tokio::sync::Mutex as AsyncMutex;

// API server state
pub struct ApiServerState {
    pub mongodb_state: Arc<AsyncMutex<MongoDbState>>,
    pub session_manager: Arc<AsyncMutex<SessionManager>>,
    pub server_handle: Option<tokio::task::JoinHandle<()>>,
    pub routes: Vec<String>,
    pub temp_dirs: Arc<AsyncMutex<HashMap<String, PathBuf>>>,
}

impl ApiServerState {
    pub fn new(mongodb_state: MongoDbState, session_manager: SessionManager) -> Self {
        Self {
            mongodb_state: Arc::new(AsyncMutex::new(mongodb_state)),
            session_manager: Arc::new(AsyncMutex::new(session_manager)),
            server_handle: None,
            routes: Vec::new(),
            temp_dirs: Arc::new(AsyncMutex::new(HashMap::new())),
        }
    }
}
[package]
name = "vue-tauri"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "vue_tauri_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = ["unstable"] }
tauri-plugin-opener = "2"
tauri-plugin-shell = "2.0.0"
serde = { version = "1", features = ["derive"] }
serde_json = "1"

anyhow = "1.0"

tokio = { version = "1.36", features = ["full"] }

mongodb = { version = "2.8.0", default-features = false, features = ["tokio-runtime"] }
futures-util = "0.3.28"
bson = "2.8.0"
uuid = { version = "1.4", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }

axum = "0.7.2"
axum-extra = { version = "0.9.0", features = ["typed-header"] }
tower-http = { version = "0.5.0", features = ["cors", "trace"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
bcrypt = "0.15"
rusqlite = "0.29.0"
tempfile = "3.8.0"
csv = "1.3.0"